[{"title":"Java函数式编程学习笔记（一）","url":"/posts/a798ff4a2a23.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在项目中需要使用一些基于MyBatis-Plus封装的CRUD接口，阅读一些文档和代码后发现在Java代码中偶尔会见到C++代码里的<strong>类作用域符号</strong><code>::</code>和<code>-&gt;</code><strong>运算符</strong>，查阅资料才了解到这两个符号在Java领域里属于函数式编程的语法内容，于是写下这篇博客以记录这段时间的学习过程。</p>\n<h1 id=\"Java函数式编程\"><a href=\"#Java函数式编程\" class=\"headerlink\" title=\"Java函数式编程\"></a>Java函数式编程</h1><h2 id=\"什么是函数式编程？\"><a href=\"#什么是函数式编程？\" class=\"headerlink\" title=\"什么是函数式编程？\"></a>什么是函数式编程？</h2><p>函数式编程是一种<strong>抽象程度很高</strong>的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种函数我们称为<strong>没有副作用的函数</strong>。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是<strong>有副作用的</strong>。</p>\n<p>函数式编程的一个特点就是，允许把<strong>函数本身</strong>作为参数传入另一个函数，还允许返回一个函数。函数式编程是把函数作为<strong>基本运算单元</strong>，函数可以作为变量，可以接收函数，还可以返回函数。</p>\n<p>历史上研究函数式编程的理论是<strong>Lambda演算</strong>，所以我们经常把支持函数式编程的编码风格称为<strong>Lambda表达式</strong>。</p>\n<h2 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h2><p>Lambda表达式是表示可传递<strong>匿名函数</strong>的一种简洁方式，Lambda表达式没有名称，但是有参数列表、函数主体、返回类型，还可能有一个可以抛出的异常列表。它是Java 8新增的特性，有了它，我们再也不用像以前那样写一堆笨重的匿名类代码了。</p>\n<p>在Java中，我们经常遇到<strong>单方法接口</strong>，即<em><strong>一个接口</strong></em>只定义了<em><strong>一个方法</strong></em>，例如：</p>\n<blockquote>\n<ul>\n<li><p>Comparator</p>\n</li>\n<li><p>Runnable</p>\n</li>\n<li><p>Callable</p>\n</li>\n</ul>\n</blockquote>\n<p>对于单方法接口，我们称之为<code>FunctionalInterface</code>，用<strong>注解</strong><code>@FunctionalInterface</code>标记。以<code>Comparator</code>为例，我们想要调用<code>Arrays.sort()</code>时，可以传入一个<code>Comparator</code>实例，以匿名类方式编写如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Arrays.sort(array, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;String&gt;() &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(String s1, String s2)</span> &#123;</span><br><span class=\"line\">　　    <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上述写法非常繁琐。从Java 8开始，我们可以用Lambda表达式替换单方法接口。改写上述代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Arrays.sort(array, (s1, s2) -&gt; &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>观察Lambda表达式的写法，它只需要写出<strong>方法定义</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(s1, s2) -&gt; &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，参数是<code>(s1, s2)</code>，参数类型可以省略，因为编译器可以<strong>自动推断出<code>String</code>类型</strong>。<code>-&gt; &#123; ... &#125;</code>表示方法体，所有代码写在内部即可。Lambda表达式没有<code>class</code>定义，因此写法非常简洁。</p>\n<p>如果只有一行<code>return ...</code>的代码，可以用更简单的写法，即<strong>省略方法体的括号</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h2><p>方法引用是Java8中引入的新特性，它提供了一种<strong>引用方法而不执行方法</strong>的方式，可以让我们重复使用现用方法的定义，作为某些Lambda表达式的另一种更简洁的写法。</p>\n<p>当你需要方法引用时，将目标引用放在<strong>分隔符</strong><code>::</code>前，方法的名称放在<strong>分隔符</strong><code>::</code>后。方法名称后<strong>不需要加括号</strong>，因为我们并没有实际调用它。方法引用提高了代码的可读性，也使逻辑更加清晰。</p>\n<p>可以构建方法引用的场景有四种：</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>指向<strong>静态方法</strong>的引用，语法：<code>类名::静态方法名</code>，类名放在<strong>分隔符</strong><code>::</code>前，静态方法名放在<strong>分隔符</strong><code>::</code>后。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(String str) -&gt; Integer.parseInt(str)</span><br></pre></td></tr></table></figure>\n\n<p>使用方法引用以后，可以简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer::parseInt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内部对象的实例方法\"><a href=\"#内部对象的实例方法\" class=\"headerlink\" title=\"内部对象的实例方法\"></a>内部对象的实例方法</h3><p>指向Lambda表达式<strong>内部对象</strong>的实例方法的引用，语法：<code>类名::实例方法名</code>，类名放在<strong>分隔符</strong><code>::</code>前，实例方法名放在<strong>分隔符</strong><code>::</code>后。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(Equipment equipment) -&gt; equipment.getBrand()</span><br></pre></td></tr></table></figure>\n\n<p>使用方法引用以后，可以简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Equipment::getBrand</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外部对象的实例方法\"><a href=\"#外部对象的实例方法\" class=\"headerlink\" title=\"外部对象的实例方法\"></a>外部对象的实例方法</h3><p>指向Lambda表达式<strong>外部对象</strong>的实例方法的引用，语法：<code>实例名::实例方法名</code>，类名放在<strong>分隔符</strong><code>::</code>前，实例方法名放在<strong>分隔符</strong><code>::</code>后。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;STR&quot;</span>;</span><br><span class=\"line\">Predicate&lt;String&gt; predicate = (String str) -&gt; type.equals(str);</span><br><span class=\"line\">System.out.println(predicate.test(<span class=\"string\">&quot;STR&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>type</code>是一个Lambda表达式外部的局部变量，使用方法引用以后，可以简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">type</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;STR&quot;</span>;</span><br><span class=\"line\">Predicate&lt;String&gt; predicate = type::equals;</span><br><span class=\"line\">System.out.println(predicate.test(<span class=\"string\">&quot;STR&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>指向<strong>构造方法</strong>的引用，语法：<code>类名::new</code>，类名放在<strong>分隔符</strong><code>::</code>前，new放在<strong>分隔符</strong><code>::</code>后。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">(String brand, String type) -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Equipment</span>(brand, type)</span><br></pre></td></tr></table></figure>\n\n<p>使用方法引用以后，可以简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Equipment::<span class=\"keyword\">new</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在一个数据库表中，存在<strong>一对多</strong>的E-R关系，对父表新增一条数据时，子表的若干条数据需要关联父表的这行数据；进一步地，需要在对父表删除一行数据时，与其关联的若干条要被<strong>同步删除</strong>，以保证数据之间的约束。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>首先分析父表与子表的关联关系，找出子表是与父表的哪一个字段关联的，这样即可根据父表的字段找到子表的数据，随后即可删除子表的数据。在编写业务逻辑时需注意：先删除子表数据，后删除父表数据。</p>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>使用其他业务方法得到一个由子表数据组成的实体数组时，需要根据每个实体的<code>id</code>进行删除。传统的写法是使用<code>for</code>循环遍历这个数组，在循环体中写一行sql语句删除逐行数据，这种写法需要创建多个临时变量储存临时数据，较为繁琐，也显得代码块较为臃肿。利用Java函数式编程的新特性即可简化代码。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>创建<code>Stream</code>储存该实体数组进行流式处理，代替<code>for</code>循环，使用<code>map</code>将数组中的每个实体转换为实体对应的<code>id</code>。<code>map</code>方法又可接收<code>Function</code>接口对象的方法引用，无需创建实例即可引用方法，进一步减少了代码量。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>假设已得到一个实体数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;EmissionCalcParamDTO&gt; emissionCalcParams</span><br></pre></td></tr></table></figure>\n\n<p>现调用一个入参为数组的<code>deleteBatchIds()</code>方法，它是MyBatis-Plus提供的接口，用于删除多行数据。调用前需先判断数组是否为空，写法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(emissionCalcParams)) &#123;</span><br><span class=\"line\">    emissionSourceCalcParamMapper.deleteBatchIds(emissionCalcParams.stream()</span><br><span class=\"line\">        .map(EmissionCalcParamDTO::getId)</span><br><span class=\"line\">        .collect(Collectors.toList()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码在把实体转换为<code>id</code>后又将其组合成数组，作为<code>deleteBatchIds()</code>的入参，可以说用一行代码解决了传统写法十几行的工作量。</p>\n<blockquote>\n<p>注意，上述编码过程中还使用到了<code>Stream</code>流和<code>map</code>方法，并使用<code>MyBatis-Plus</code>简化数据库操作，上述代码基于<code>Spring Boot</code>框架进行编写。对于上述使用到的技术，我将在后面的文章中详细介绍。</p>\n</blockquote>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255943847278976\">函数式编程 - 廖雪峰的官方网站</a></li>\n</ul>\n","categories":["学习笔记"],"tags":["Java","开发"]},{"title":"Java函数式编程学习笔记（三）","url":"/posts/481fb0c75300.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>时隔三个月，我终于回归到技术博客写作中了。这段时间我经历了一个半月的应届生新员工培训，之后接续实习期间完成的工作，继续进行业务需求的开发。由于开发时实在分不出精力撰写文章，博客也被闲置了将近3个月，在此期间博客仅部署了两次平台框架版本的例行升级。</p>\n<p>言归正传，最近在业务逻辑编写工作中用到了不少<code>Stream</code>流和<code>Lambda</code>函数。使用不同的<code>Stream</code>操作、编写不同功能的<code>Lambda</code>函数，能够输出各式各样的数据结构，从而满足业务逻辑的需求。于是写下这篇文章以作总结。这篇文章中的每个代码片段都是我在实际开发中编写的，希望能对各位有些帮助。</p>\n<blockquote>\n<p>Talk is cheap, show me the code.</p>\n</blockquote>\n<h1 id=\"经典案例\"><a href=\"#经典案例\" class=\"headerlink\" title=\"经典案例\"></a>经典案例</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; alarmIdSet = realTimeData.entrySet().stream().filter(it -&gt; Objects.nonNull(it.getValue()) &amp;&amp; it.getValue() &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        .map(it -&gt; Integer.valueOf(it.getKey()))</span><br><span class=\"line\">        .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>\n\n<p>这段代码是<code>Stream</code>流非常常见的使用案例，把常见的<code>fliter</code>、<code>map</code>、<code>collect</code>方法都用到了，最终将一个<code>Map</code>的<code>EntrySet</code>转换成所需条件的<code>KeySet</code>。</p>\n<blockquote>\n<p>对<code>Stream</code>流不太了解的同学，可以查阅与本文同一专题的<a href=\"https://www.dongzhenxian.com/posts/6ccb0645c089.html\">《Java函数式编程学习笔记（二）》</a>。该篇文章较为详细地介绍了<code>Stream</code>流的各种操作。</p>\n</blockquote>\n<h1 id=\"对象List转Map\"><a href=\"#对象List转Map\" class=\"headerlink\" title=\"对象List转Map\"></a>对象List转Map</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Long, Integer&gt; preInspectionMap = preInspectionList.stream()</span><br><span class=\"line\">        .collect(Collectors.toMap(PreInspectionDTO::getId, PreInspectionDTO::getDeviceType));</span><br></pre></td></tr></table></figure>\n\n<p>如果对<code>Stream</code>有了基本的了解，那么这段代码就一目了然了，它使用<code>Collectors.toMap</code>方法取了一个<code>POJO</code>对象的两个属性分别作为<code>Map</code>的<code>Key</code>与<code>Value</code>，最终将对象<code>List</code>转换为<code>Map</code>。</p>\n<p>值得一提的是，当<code>Collectors.toMap</code>方法有三个入参时，除了前两个入参表示<code>Key</code>和<code>Value</code>的映射方法外，第三个入参需传入一个<code>Lambda</code>，用于定义当<code>key</code>发生冲突时的处理方式。<code>(v1, v2) -&gt; v2</code>表示如果新插入的键值对的<code>Key</code>已存在，就用这个<code>Key</code>的新<code>Value</code>替换旧<code>Value</code>。下面这段代码就符合这种场景。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> apiResult.getData().stream()</span><br><span class=\"line\">        .collect(Collectors.toMap(it -&gt; it.getMonitoredLabel() + <span class=\"string\">&quot;_&quot;</span> + it.getMonitoredId(),</span><br><span class=\"line\">        it -&gt; it,</span><br><span class=\"line\">        (v1, v2) -&gt; v2));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对<code>Lambda</code>不太了解的同学，可以查阅与本文同一专题的<a href=\"https://www.dongzhenxian.com/posts/a798ff4a2a23.html\">《Java函数式编程学习笔记（一）》</a>。该篇文章简短地介绍了Java函数式编程的概念和Java 8的<code>Lambda</code>特性。</p>\n</blockquote>\n<h1 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h1><p>Stream拥有强大的分组输出操作，使用<code>Collectors.groupingBy</code>方法传入不同<code>Lambda</code>即可实现不同功能的归类。这里归纳了三种，分别是<strong>归类为对象List</strong>、<strong>归类并统计数量</strong>、<strong>归类为对象属性List</strong>。</p>\n<h2 id=\"归类为对象List\"><a href=\"#归类为对象List\" class=\"headerlink\" title=\"归类为对象List\"></a>归类为对象List</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Long, List&lt;SystemEventStatisticsVo&gt;&gt; eventGroups = systemEventStatisticsVos.stream()</span><br><span class=\"line\">        .collect(Collectors.groupingBy(SystemEventStatisticsVo::getLogtime));</span><br></pre></td></tr></table></figure>\n\n<p>这是最基本的归类功能，只需在<code>groupingBy</code>方法中传入POJO对象的一个属性的<code>Getter</code>方法引用，就能按这个属性分组输出<code>Map</code>，此时<code>Map</code>的<code>Value</code>数据类型为对象<code>List</code>。</p>\n<h2 id=\"归类并统计数量\"><a href=\"#归类并统计数量\" class=\"headerlink\" title=\"归类并统计数量\"></a>归类并统计数量</h2><blockquote>\n<p>基本案例</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Long, Long&gt; preInspectionEventMap = eventList.stream().</span><br><span class=\"line\">        collect(Collectors.groupingBy(SystemEventDTO::getObjectId, Collectors.counting()));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将方法引用替换为<code>Lambda</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Long&gt; hiddenDangerMap = hiddenDangerAccountList.stream()</span><br><span class=\"line\">        .collect(Collectors.groupingBy(it -&gt; roomIdName.get(it.getRoomId()), Collectors.counting()));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>稍微复杂一点的<code>Lambda</code>，内容是条件运算</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Long&gt; enterpriseGroups = enterpriseList.stream().collect(</span><br><span class=\"line\">        Collectors.groupingBy(it -&gt; Objects.isNull(it.getEnterprisefacilityinstallstatus()) ?</span><br><span class=\"line\">                -<span class=\"number\">1</span> : it.getEnterprisefacilityinstallstatus(), Collectors.counting()));</span><br></pre></td></tr></table></figure>\n\n<p>这三段代码都在<code>groupingBy</code>方法中传入了一个<code>Collectors.counting</code>，用于在分组的同时统计每组元素的数量。</p>\n<h2 id=\"归类为对象属性List\"><a href=\"#归类为对象属性List\" class=\"headerlink\" title=\"归类为对象属性List\"></a>归类为对象属性List</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Long, List&lt;Long&gt;&gt; roomPreInspectionMap = preInspectionList.stream()</span><br><span class=\"line\">        .collect(Collectors.groupingBy(PreInspectionDTO::getRoomId,</span><br><span class=\"line\">                Collectors.mapping(PreInspectionDTO::getId, Collectors.toList())));</span><br></pre></td></tr></table></figure>\n\n<p>这段代码在<code>groupingBy</code>方法中传入了一个<code>Collectors.mapping</code>，将分组的功能改为输出对象的属性<code>List</code>，相当于在归类为对象<code>List</code>后将对象<code>List</code>额外做了一次<code>Stream</code>流的<code>Map</code>操作。</p>\n<h1 id=\"统计数量\"><a href=\"#统计数量\" class=\"headerlink\" title=\"统计数量\"></a>统计数量</h1><p>Java中统计数量的逻辑可以使用<code>for</code>循环遍历集合来实现，也可以使用<code>Stream</code>的<code>reduce</code>操作来实现。</p>\n<h2 id=\"使用merge\"><a href=\"#使用merge\" class=\"headerlink\" title=\"使用merge\"></a>使用merge</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">resultMap.merge(EquipmentTypeEnum.of(preInspectionTypeMap.get(it.getObjectId())), <span class=\"number\">1L</span>, Long::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">resultMap.merge(ConfirmEventStatusEnum.of(it.getConfirmEventStatus()), <span class=\"number\">1L</span>, Long::sum);</span><br></pre></td></tr></table></figure>\n\n<p>上面两段代码都是将<code>Map</code>中一个<code>Key</code>对应的<code>Value</code>作为计数器，用<code>merge</code>方法实现了累加功能，从而达到统计数量的效果。<code>merge</code>方法的三个入参分别是<code>Key</code>的取值；每次取到相同<code>Key</code>时累加的值；实现累加的<code>Lambda</code>或方法引用。</p>\n<p>此处<code>merge</code>方法的含义为：每次取到相同的<code>Key</code>时，在这个<code>Key</code>对应的<code>Value</code>基础上加<code>1</code>。事实上<code>merge</code>不止有累加的功能，更多功能还等待着我们去发掘。</p>\n<h2 id=\"使用reduce\"><a href=\"#使用reduce\" class=\"headerlink\" title=\"使用reduce\"></a>使用reduce</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">eventCount</span> <span class=\"operator\">=</span> eventList.stream().map(SystemEventStatisticsVo::getCount)</span><br><span class=\"line\">        .reduce(<span class=\"number\">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>\n\n<p>前面说到，<code>reduce</code>方法是<code>Stream</code>流的一种聚合操作，能将所有元素聚合成一个结果。这里是取了<code>POJO</code>对象的<code>Count</code>属性并做累加操作，得到所有元素<code>Count</code>属性的总和。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">eventCount</span> <span class=\"operator\">=</span> roomPreInspectionList.stream().reduce(<span class=\"number\">0L</span>, (total, it) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">eventNum</span> <span class=\"operator\">=</span> Objects.isNull(preInspectionEventMap.get(it)) ? <span class=\"number\">0L</span> : preInspectionEventMap.get(it);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total + eventNum;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码将一段<code>Lambda</code>作为聚合方法，按聚合函数的逻辑输出一个结果。</p>\n<h1 id=\"使用Optional\"><a href=\"#使用Optional\" class=\"headerlink\" title=\"使用Optional\"></a>使用Optional</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Optional&lt;TrendDataVo&gt; first = data.stream().filter(d -&gt; paramsIsEquals(d, l)).findFirst();</span><br><span class=\"line\">first.ifPresent(trendDataVo -&gt; loadCurveVo.setDataList(trendDataVo.getDataList()));</span><br></pre></td></tr></table></figure>\n\n<p>这段代码中，<code>Optional</code>的作用是在无法确定一个<code>Stream</code>的元素是否存在时定义的一种数据结构。当元素存在时，才执行<code>ifPresent</code>方法中的逻辑，是处理NPE或数组越界异常时替代<code>if</code>语句的更优雅的一种方法。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889\">使用Stream - 廖雪峰的官方网站</a></li>\n</ul>\n","categories":["学习笔记"],"tags":["Java","开发"]},{"title":"Java函数式编程学习笔记（四）","url":"/posts/d8ee8d867c5e.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前段时间，我参与了一些Java统计程序的编写，同时开发了获取这些统计结果的接口。在这些逻辑中，我大量使用<code>Stream</code>流对数据进行分类、筛选、整理和统计，使用到了和之前有所不同的<code>Stream</code>操作，在这里进行总结。</p>\n<h1 id=\"统计合计值\"><a href=\"#统计合计值\" class=\"headerlink\" title=\"统计合计值\"></a>统计合计值</h1><p>统计总和是统计程序或页面展示数据里常见的内容，与之前所讲的统计数量不同的是，总和的概念不局限于元素的数量，它还可能是元素一个字段数据的合计，这时仅使用<code>Collectors.counting()</code>是不能满足需求的。因此，此处引入了针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>的<code>sum()</code>方法以及<code>summingInt()</code>、<code>summingLong()</code>方法满足业务需求。</p>\n<h2 id=\"直接输出\"><a href=\"#直接输出\" class=\"headerlink\" title=\"直接输出\"></a>直接输出</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">response.setCount(entry.getValue().stream().mapToLong(MoEventCount::getCount).sum());</span><br><span class=\"line\">response.setLowDuration(lowVoltageList.stream().mapToInt(VoltageFluctuation::getDuration).sum() / <span class=\"number\">60d</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这里取元素需要统计的字段，使用<code>mapToLong()</code>或<code>mapToInt()</code>转换成对应的<code>LongStream</code>或<code>IntStream</code>后，再使用<code>sum()</code>方法输出合计值。</p>\n<h2 id=\"分类后输出\"><a href=\"#分类后输出\" class=\"headerlink\" title=\"分类后输出\"></a>分类后输出</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Integer&gt; collectVolDurationMap = queryList.stream()</span><br><span class=\"line\">        .collect(Collectors.groupingBy(VoltageFluctuation::getVoltageLowerLimit,</span><br><span class=\"line\">                Collectors.summingInt(VoltageFluctuation::getDuration)));</span><br><span class=\"line\">Map&lt;Long, Long&gt; logTimeMap = list.stream()</span><br><span class=\"line\">        .collect(Collectors.groupingBy(VoltageFluctuation::getLogTime,</span><br><span class=\"line\">                Collectors.summingLong(VoltageFluctuation::getDuration)));</span><br></pre></td></tr></table></figure>\n\n<p>这里在<code>groupingBy</code>的映射函数中使用<code>summingInt()</code>或<code>summingLong()</code>，统计了一个分类下的合计值，整合了直接输出时的逻辑。</p>\n<h1 id=\"给数据打上标签\"><a href=\"#给数据打上标签\" class=\"headerlink\" title=\"给数据打上标签\"></a>给数据打上标签</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> queryList.stream().collect(Collectors.toMap(</span><br><span class=\"line\">        x -&gt; String.valueOf(x.getLogTime()) + x.getAggregationType() + x.getAggregationCycle(),</span><br><span class=\"line\">        x -&gt; x, (x1, x2) -&gt; x2));</span><br></pre></td></tr></table></figure>\n\n<p>这种操作常见于将数据库中查到的数据根据需要取用的场景，代价是内存开销比较大，当数据量很大时需慎用。</p>\n<h1 id=\"查找最大值\"><a href=\"#查找最大值\" class=\"headerlink\" title=\"查找最大值\"></a>查找最大值</h1><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Optional&lt;LoadRateValue&gt; maxValue = loadRateValues.stream()</span><br><span class=\"line\">        .filter(d -&gt; Objects.nonNull(d.getValue()))</span><br><span class=\"line\">        .max(Comparator.comparingDouble(LoadRateValue::getValue));</span><br></pre></td></tr></table></figure>\n\n<p>与之前所讲的<code>findFirst()</code>类似，这里取一个集合中的最大值，返回一个<code>Optional</code>，当元素存在时，执行后续<code>ifPresent</code>方法中的逻辑。此外还可以引入<code>orElse()</code>方法以指定元素不存在时的缺省值。</p>\n<h1 id=\"peek与foreach\"><a href=\"#peek与foreach\" class=\"headerlink\" title=\"peek与foreach\"></a>peek与foreach</h1><p>项目代码中有这样一段逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">dataLogPoiDeviceIdMap.putAll(dataLogPoiResult.getData().stream()</span><br><span class=\"line\">        .peek(it -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.isNull(it.getDataBasePoi()) &amp;&amp; Objects.isNull(it.getCachePoi())) &#123;</span><br><span class=\"line\">                it.setDataBasePoi(DateUtils.computeStartOfHour(System.currentTimeMillis()));</span><br><span class=\"line\">                it.setCachePoi(DateUtils.computeStartOfHour(System.currentTimeMillis()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.isNull(it.getDataBasePoi())) &#123;</span><br><span class=\"line\">                it.setDataBasePoi(globalStartTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.isNull(it.getCachePoi())) &#123;</span><br><span class=\"line\">                it.setCachePoi(globalStartTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .collect(Collectors.groupingBy(it -&gt; Math.max(it.getDataBasePoi(), it.getCachePoi())))</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>这里使用到了<code>peek()</code>方法。在<code>Stream</code>中，<code>peek()</code>与<code>foreach</code>都能遍历一个集合的元素，它们的区别是：<code>peek()</code>是中间操作，不会对每个元素进行处理；而<code>foreach()</code>是最终操作，保证对<code>Stream</code>里的每个元素都应用某个方法。</p>\n<p>出于性能考虑，<code>Stream</code>被设计为<strong>元素只有在最终操作需要时才会被处理</strong>。如果没有最终操作的<em>拉动</em>，那么在<code>Stream</code>中就没有操作会真正执行。</p>\n<p>上面的例子中，<code>.collect(Collectors.groupingBy())</code>就是一个最终操作，而且这个操作会<em>拉动</em>所有元素。这样一来，每个元素都会被应用<code>peek()</code>方法，所以放在这里没有问题。</p>\n<p>事实上，<code>peek()</code>最合适的用法是打印流经的每个元素的状态，如日志或某个字段，例如下面这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">&quot;one&quot;</span>, <span class=\"string\">&quot;two&quot;</span>, <span class=\"string\">&quot;three&quot;</span>, <span class=\"string\">&quot;four&quot;</span>)</span><br><span class=\"line\">        .filter(e -&gt; e.length() &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">        .peek(e -&gt; System.out.println(<span class=\"string\">&quot;Filtered value: &quot;</span> + e))</span><br><span class=\"line\">        .map(String::toUpperCase)</span><br><span class=\"line\">        .peek(e -&gt; System.out.println(<span class=\"string\">&quot;Mapped value: &quot;</span> + e))</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<p>如果要对这段项目代码做改进，可以将<code>dataLogPoiResult.getData()</code>这个集合中的元素做<code>foreach()</code>操作，然后将结果用<code>Collectors.groupingBy()</code>做分类，最后放在<code>putAll()</code>方法中，这样代码可读性和可靠性都会增加。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/VoisSurTonChemin/article/details/122378636\">Java stream中peek()的合理用法</a></li>\n</ul>\n","categories":["学习笔记"],"tags":["Java","开发"]},{"title":"Java函数式编程学习笔记（二）","url":"/posts/6ccb0645c089.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>上次我们谈到，在Java代码中使用<code>Lambda</code>可以显著减少代码量，提高开发效率。那么在Java项目开发过程中，还有一个非常好用的接口：<code>Stream Api</code>，我们叫它<code>Stream</code>流。</p>\n<blockquote>\n<p>注意：这个<code>Stream</code>不同于<code>java.io</code>的<code>InputStream</code>和<code>OutputStream</code>，它代表的是若干个任意Java对象元素的序列，这一点特性和<code>Collection</code>有点相似，但是<code>Stream</code>并不会真正存储这些元素，而是根据需要来实时计算和存储，真正的计算通常发生在最终结果的输出，是一种<code>惰性计算</code>。</p>\n</blockquote>\n<p><code>Stream</code>使用一种类似用<code>SQL</code>语句从数据库查询数据的直观方式来提高Java集合运算逻辑的编码效率，让我们能够写出<strong>高效率</strong>、<strong>干净</strong>、<strong>简洁</strong>的代码。在使用它的时候，我感受到了前所未有的便利。</p>\n<h1 id=\"Stream流\"><a href=\"#Stream流\" class=\"headerlink\" title=\"Stream流\"></a>Stream流</h1><h2 id=\"什么是Stream？\"><a href=\"#什么是Stream？\" class=\"headerlink\" title=\"什么是Stream？\"></a>什么是Stream？</h2><p><code>Stream</code>是一个来自数据源的元素队列并支持转换与聚合操作。</p>\n<ul>\n<li><strong>元素</strong>是特定类型的对象，它们形成一个队列。Java中的<code>Stream</code>并不会存储元素，而是按需计算。</li>\n<li><strong>数据源</strong>是流的来源。可以是<code>集合</code>，<code>数组</code>，<code>I/O channel</code>，产生器<code>generator</code>等。</li>\n<li><strong>转换操作</strong>与<strong>聚合操作</strong>是类似SQL语句一样的操作，可以使用<code>map</code>, <code>filter</code>, <code>reduce</code>, <code>find</code>, <code>match</code>, <code>sorted</code>等方法将一个<code>Stream</code>转换成另一个<code>Stream</code>。</li>\n</ul>\n<p><code>Stream</code>还有两个区别于<code>Collection</code>的基本特征：</p>\n<ul>\n<li><strong>Pipelining</strong>: 中间操作都会返回一个流对象，而不是最终的集合等结构。这样多个操作可以串联成一个管道，如同流式风格(<code>fluent style</code>)。这样做可以对操作进行优化，比如延迟执行(<code>laziness</code>)和短路(<code>short-circuiting</code>)。</li>\n<li><strong>内部迭代</strong>： 以前我们对集合遍历都是通过<code>Iterator</code>或者<code>For-Each</code>代码块的方式, 显式的在集合外部进行迭代，这叫做外部迭代。<code>Stream</code>提供了内部迭代的方式，通过上面介绍的<strong>转换与聚合操作</strong>实现。</li>\n</ul>\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><p>我们可以通过许多方式将常见的结构转换成<code>Stream</code>来使用。</p>\n<h3 id=\"Stream-of\"><a href=\"#Stream-of\" class=\"headerlink\" title=\"Stream.of()\"></a>Stream.of()</h3><p>创建<code>Stream</code>最简单的方式是直接用<code>Stream.of()</code>静态方法，传入可变参数即创建了一个能输出确定元素的<code>Stream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// forEach()方法相当于内部循环调用，</span></span><br><span class=\"line\">        <span class=\"comment\">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span></span><br><span class=\"line\">        stream.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p>\n<h3 id=\"基于数组或Collection\"><a href=\"#基于数组或Collection\" class=\"headerlink\" title=\"基于数组或Collection\"></a>基于数组或Collection</h3><p>第二种创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者Collection持有的元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream1 = Arrays.stream(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[] &#123; <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span> &#125;);</span><br><span class=\"line\">        Stream&lt;String&gt; stream2 = List.of(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;Y&quot;</span>, <span class=\"string\">&quot;Z&quot;</span>).stream();</span><br><span class=\"line\">        stream1.forEach(System.out::println);</span><br><span class=\"line\">        stream2.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>事实上，所有<code>Collection</code>都可以轻松地转换成<code>Stream</code>，只需调用<code>stream()</code>方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class=\"line\">        Vector&lt;String&gt; vector = <span class=\"keyword\">new</span> <span class=\"title class_\">Vector</span>&lt;&gt;();</span><br><span class=\"line\">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述两种创建<code>Stream</code>的方法都是把一个现有的序列变为<code>Stream</code>，它的元素是固定的。</p>\n<h3 id=\"基于Supplier\"><a href=\"#基于Supplier\" class=\"headerlink\" title=\"基于Supplier\"></a>基于Supplier</h3><p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>\n\n<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>\n<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;Integer&gt; natual = Stream.generate(<span class=\"keyword\">new</span> <span class=\"title class_\">NatualSupplier</span>());</span><br><span class=\"line\">        <span class=\"comment\">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class=\"line\">        natual.limit(<span class=\"number\">20</span>).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NatualSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Supplier</span>&lt;Integer&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Integer <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因为Java的范型不支持基本类型，所以我们无法用<code>Stream&lt;int&gt;</code>这样的类型，会发生编译错误。为了保存<code>int</code>，只能使用<code>Stream&lt;Integer&gt;</code>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>，它们的使用方法和范型<code>Stream</code>没有大的区别，设计这三个<code>Stream</code>的目的是提高运行效率。</p>\n</blockquote>\n<h2 id=\"操作Stream\"><a href=\"#操作Stream\" class=\"headerlink\" title=\"操作Stream\"></a>操作Stream</h2><p>前面提到，我们可以通过一些转换与聚合操作对<code>Stream</code>进行一些处理，来达到处理数据的目的。我们通常把<code>Stream</code>的操作写成<strong>链式操作</strong>，这样显得代码更简洁。</p>\n<h3 id=\"使用map\"><a href=\"#使用map\" class=\"headerlink\" title=\"使用map\"></a>使用map</h3><p><code>map</code>方法是最常用的转换操作。它能够把一种操作运算，映射到一个序列的每一个元素上，可以将一种元素类型转换成另一种元素类型。</p>\n<p>例如，对<code>x</code>计算它的平方，可以使用函数<code>f(x) = x * x</code>。我们把这个函数映射到一个序列<code>1，2，3，4，5</code>上，就得到了另一个序列<code>1，4，9，16，25</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; s1 = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">Stream&lt;Integer&gt; s2 = s1.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>map()</code>，不但能完成数学计算，对于字符串操作，以及任何Java对象都是非常有用的。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List.of(<span class=\"string\">&quot;  Apple &quot;</span>, <span class=\"string\">&quot; pear &quot;</span>, <span class=\"string\">&quot; ORANGE&quot;</span>, <span class=\"string\">&quot; BaNaNa &quot;</span>)</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .map(String::trim) <span class=\"comment\">// 去空格</span></span><br><span class=\"line\">                .map(String::toLowerCase) <span class=\"comment\">// 变小写</span></span><br><span class=\"line\">                .forEach(System.out::println); <span class=\"comment\">// 打印</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用filter\"><a href=\"#使用filter\" class=\"headerlink\" title=\"使用filter\"></a>使用filter</h3><p><code>filter()</code>是另一种转换操作，它能够对一个<code>Stream</code>的每个元素进行判断，不满足条件的就被过滤掉了，剩下的满足条件的元素就构成了一个新的<code>Stream</code>。</p>\n<p>例如，我们对<code>1，2，3，4，5</code>这个<code>Stream</code>调用<code>filter()</code>，传入的测试函数<code>f(x) = x % 2 != 0</code>用来判断元素是否是奇数，这样就过滤掉偶数，只剩下奇数，因此我们得到了另一个序列<code>1，3，5</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        IntStream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">                .filter(n -&gt; n % <span class=\"number\">2</span> != <span class=\"number\">0</span>)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>filter()</code>除了常用于数值外，也可应用于任何Java对象。例如，从一组给定的<code>LocalDate</code>中过滤掉工作日，以得到休息日：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream.generate(<span class=\"keyword\">new</span> <span class=\"title class_\">LocalDateSupplier</span>())</span><br><span class=\"line\">                .limit(<span class=\"number\">31</span>)</span><br><span class=\"line\">                .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LocalDateSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Supplier</span>&lt;LocalDate&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">LocalDate</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> LocalDate.of(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocalDate <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start.plusDays(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用reduce\"><a href=\"#使用reduce\" class=\"headerlink\" title=\"使用reduce\"></a>使用reduce</h3><p><code>reduce()</code>是一种聚合操作，它可以把一个<code>Stream</code>的所有元素按照聚合函数聚合成一个结果。我们以一个简单的求和运算为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">                .reduce(<span class=\"number\">0</span>, (acc, n) -&gt; acc + n);</span><br><span class=\"line\">        System.out.println(sum); <span class=\"comment\">// 45</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>reduce()</code>方法有两个参数，第一个参数是一个初始值，第二个参数是聚合函数。<code>reduce()</code>操作首先初始化结果为指定值（这里是<code>0</code>），紧接着，<code>reduce()</code>对每个元素依次调用<code>(acc, n) -&gt; acc + n</code>，其中，<code>acc</code>是上次计算的结果。</p>\n<p>我们还可以把求和改成求积，代码也十分简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">                .reduce(<span class=\"number\">1</span>, (acc, n) -&gt; acc * n);</span><br><span class=\"line\">        System.out.println(s); <span class=\"comment\">// 362880</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：计算求积时，初始值必须设置为<code>1</code>。</p>\n</blockquote>\n<p>除了可以对数值进行累积计算外，灵活运用<code>reduce()</code>也可以对Java对象进行操作。下面的代码演示了如何将配置文件的每一行配置通过<code>map()</code>和<code>reduce()</code>操作聚合成一个<code>Map&lt;String, String&gt;</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按行读取配置文件:</span></span><br><span class=\"line\">        List&lt;String&gt; props = List.of(<span class=\"string\">&quot;profile=native&quot;</span>, <span class=\"string\">&quot;debug=true&quot;</span>, <span class=\"string\">&quot;logging=warn&quot;</span>, <span class=\"string\">&quot;interval=500&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = props.stream()</span><br><span class=\"line\">                <span class=\"comment\">// 把k=v转换为Map[k]=v:</span></span><br><span class=\"line\">                .map(kv -&gt; &#123;</span><br><span class=\"line\">                    String[] ss = kv.split(<span class=\"string\">&quot;\\\\=&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> Map.of(ss[<span class=\"number\">0</span>], ss[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                <span class=\"comment\">// 把所有Map聚合到一个Map:</span></span><br><span class=\"line\">                .reduce(<span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, String&gt;(), (m, kv) -&gt; &#123;</span><br><span class=\"line\">                    m.putAll(kv);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 打印结果:</span></span><br><span class=\"line\">        map.forEach((k, v) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(k + <span class=\"string\">&quot; = &quot;</span> + v);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h3><p>除了前面介绍的常用操作外，<code>Stream</code>还提供了一系列非常有用的方法。</p>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>对<code>Stream</code>的元素进行排序十分简单，只需调用<code>sorted()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>)</span><br><span class=\"line\">            .stream()</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此方法要求<code>Stream</code>的每个元素必须实现<code>Comparable</code>接口。如果要自定义排序，传入指定的<code>Comparator</code>即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>)</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .sorted(String::compareToIgnoreCase)</span><br><span class=\"line\">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h4><p>对一个<code>Stream</code>的元素进行去重，可以直接用<code>distinct()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;D&quot;</span>)</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .distinct()</span><br><span class=\"line\">    .collect(Collectors.toList()); <span class=\"comment\">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"截取\"><a href=\"#截取\" class=\"headerlink\" title=\"截取\"></a>截取</h4><p>截取操作常用于把一个无限的<code>Stream</code>转换成有限的<code>Stream</code>，<code>skip()</code>用于跳过当前<code>Stream</code>的前<code>N</code>个元素，<code>limit()</code>用于截取当前<code>Stream</code>最多前<code>N</code>个元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;F&quot;</span>)</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .skip(<span class=\"number\">2</span>) <span class=\"comment\">// 跳过A, B</span></span><br><span class=\"line\">    .limit(<span class=\"number\">3</span>) <span class=\"comment\">// 截取C, D, E</span></span><br><span class=\"line\">    .collect(Collectors.toList()); <span class=\"comment\">// [C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h4><p>将两个<code>Stream</code>合并为一个<code>Stream</code>可以使用<code>Stream</code>的静态方法<code>concat()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s1 = List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>).stream();</span><br><span class=\"line\">Stream&lt;String&gt; s2 = List.of(<span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>).stream();</span><br><span class=\"line\"><span class=\"comment\">// 合并:</span></span><br><span class=\"line\">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class=\"line\">System.out.println(s.collect(Collectors.toList())); <span class=\"comment\">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h4><p>如果<code>Stream</code>的元素是集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>),</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>));</span><br></pre></td></tr></table></figure>\n\n<p>由上面三个<code>List</code>组成的<code>Stream</code>形成了一个二维数组的形式，而我们希望把上述<code>Stream</code>转换为<code>Stream&lt;Integer&gt;</code>，就可以使用<code>flatMap()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>\n<p>因此，所谓<code>flatMap()</code>，是指把<code>Stream</code>的每个元素（这里是<code>List</code>）映射为<code>Stream</code>，然后合并成一个新的<code>Stream</code>，即把二维数组转成一维的。</p>\n<h4 id=\"并行\"><a href=\"#并行\" class=\"headerlink\" title=\"并行\"></a>并行</h4><p>通常情况下，对<code>Stream</code>的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理<code>Stream</code>的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p>\n<p>把一个普通<code>Stream</code>转换为可以并行处理的<code>Stream</code>非常简单，只需要用<code>parallel()</code>进行转换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = ...</span><br><span class=\"line\">String[] result = s.parallel() <span class=\"comment\">// 变成一个可以并行处理的Stream</span></span><br><span class=\"line\">        .sorted() <span class=\"comment\">// 可以进行并行排序</span></span><br><span class=\"line\">        .toArray(String[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p>或者直接在创建<code>Stream</code>时使用<code>parallelStream()</code>方法，为集合创建并行流：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> ...</span><br><span class=\"line\">Stream&lt;String&gt; s = list.parallelStream() <span class=\"comment\">// 生成一个可以并行处理的Stream</span></span><br><span class=\"line\">        .sorted() <span class=\"comment\">// 可以进行并行排序</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"其他聚合方法\"><a href=\"#其他聚合方法\" class=\"headerlink\" title=\"其他聚合方法\"></a>其他聚合方法</h4><p>除了<code>reduce()</code>和<code>collect()</code>外，<code>Stream</code>还有一些常用的聚合方法：</p>\n<ul>\n<li><code>count()</code>：用于返回元素个数；</li>\n<li><code>max(Comparator&lt;? super T&gt; cp)</code>：找出最大元素；</li>\n<li><code>min(Comparator&lt;? super T&gt; cp)</code>：找出最小元素。</li>\n</ul>\n<p>针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>，还额外提供了以下聚合方法：</p>\n<ul>\n<li><code>sum()</code>：对所有元素求和；</li>\n<li><code>average()</code>：对所有元素求平均数。</li>\n</ul>\n<p>还有一些方法，用来测试<code>Stream</code>的元素是否满足以下条件：</p>\n<ul>\n<li><code>boolean allMatch(Predicate&lt;? super T&gt;)</code>：测试是否所有元素均满足测试条件；</li>\n<li><code>boolean anyMatch(Predicate&lt;? super T&gt;)</code>：测试是否至少有一个元素满足测试条件。</li>\n</ul>\n<p>最后一个常用的方法是<code>forEach()</code>，它可以循环处理<code>Stream</code>的每个元素，我们经常传入<code>System.out::println</code>来打印<code>Stream</code>的元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = ...</span><br><span class=\"line\">s.forEach(str -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + str);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"输出Stream\"><a href=\"#输出Stream\" class=\"headerlink\" title=\"输出Stream\"></a>输出Stream</h2><p>我们使用<code>Stream</code>对数据进行了处理，最后就需要输出<code>Stream</code>里的元素了。</p>\n<p>在此之前，我们先对之前介绍的操作分个类：一类是转换操作，即把一个<code>Stream</code>转换为另一个<code>Stream</code>，例如<code>map()</code>和<code>filter()</code>，另一类是聚合操作，即对<code>Stream</code>的每个元素进行计算，得到一个确定的结果，例如<code>reduce()</code>。</p>\n<p>大家有没有注意到，在介绍<code>reduce()</code>方法时，我们用<code>reduce()</code>编写了求和与求积运算，它们返回的并不是另一个<code>Stream</code>，而是一个值<code>sum</code>。因此，上面两种操作的区别就是：转换操作并不会触发任何计算；而聚合操作会立刻促使<code>Stream</code>输出它的每一个元素，并依次纳入计算，以获得最终结果。所以，我们可以使用聚合操作输出<code>Stream</code>。</p>\n<h3 id=\"输出为List\"><a href=\"#输出为List\" class=\"headerlink\" title=\"输出为List\"></a>输出为List</h3><p><code>reduce()</code>只是一种聚合操作，如果我们希望把<code>Stream</code>的元素保存到集合，例如<code>List</code>，因为<code>List</code>的元素是确定的Java对象，因此，把<code>Stream</code>变为<code>List</code>不是一个转换操作，而是一个聚合操作，它会强制<code>Stream</code>输出每个元素。</p>\n<p>下面的代码演示了如何将一组<code>String</code>先过滤掉空字符串，然后把非空字符串保存到<code>List</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">null</span>, <span class=\"string\">&quot;Pear&quot;</span>, <span class=\"string\">&quot;  &quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">        List&lt;String&gt; list = stream.filter(s -&gt; s != <span class=\"literal\">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把Stream的每个元素收集到<code>List</code>的方法是调用<code>collect()</code>并传入<code>Collectors.toList()</code>对象，它实际上是一个<code>Collector</code>实例，通过类似<code>reduce()</code>的操作，把每个元素添加到一个收集器中，这里实际上是<code>ArrayList</code>。</p>\n<p>类似的，<code>collect(Collectors.toSet())</code>可以把<code>Stream</code>的每个元素收集到<code>Set</code>中。</p>\n<h3 id=\"输出为数组\"><a href=\"#输出为数组\" class=\"headerlink\" title=\"输出为数组\"></a>输出为数组</h3><p>把Stream的元素输出为数组和输出为<code>List</code>类似，我们只需要调用<code>toArray()</code>方法，并传入数组的<em>构造方法</em>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">String[] array = list.stream().toArray(String[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意到传入的<em>构造方法</em>是<code>String[]::new</code>，它的签名实际上是<code>IntFunction&lt;String[]&gt;</code>定义的<code>String[] apply(int)</code>，即传入<code>int</code>参数，获得<code>String[]</code>数组的返回值。</p>\n<h3 id=\"输出为Map\"><a href=\"#输出为Map\" class=\"headerlink\" title=\"输出为Map\"></a>输出为Map</h3><p>如果我们要把<code>Stream</code>的元素收集到<code>Map</code>中，就稍微麻烦一点。因为对于每个元素，添加到<code>Map</code>时都需要<code>key</code>和<code>value</code>，因此，我们要指定两个映射函数，分别把元素映射为<code>key</code>和<code>value</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;APPL:Apple&quot;</span>, <span class=\"string\">&quot;MSFT:Microsoft&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = stream</span><br><span class=\"line\">                .collect(Collectors.toMap(</span><br><span class=\"line\">                        <span class=\"comment\">// 把元素s映射为key:</span></span><br><span class=\"line\">                        s -&gt; s.substring(<span class=\"number\">0</span>, s.indexOf(<span class=\"string\">&#x27;:&#x27;</span>)),</span><br><span class=\"line\">                        <span class=\"comment\">// 把元素s映射为value:</span></span><br><span class=\"line\">                        s -&gt; s.substring(s.indexOf(<span class=\"string\">&#x27;:&#x27;</span>) + <span class=\"number\">1</span>)));</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分组输出\"><a href=\"#分组输出\" class=\"headerlink\" title=\"分组输出\"></a>分组输出</h3><p><code>Stream</code>还有一个强大的分组功能，可以按组输出。我们看下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Blackberry&quot;</span>, <span class=\"string\">&quot;Coconut&quot;</span>, <span class=\"string\">&quot;Avocado&quot;</span>, <span class=\"string\">&quot;Cherry&quot;</span>, <span class=\"string\">&quot;Apricots&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(s -&gt; s.substring(<span class=\"number\">0</span>, <span class=\"number\">1</span>), Collectors.toList()));</span><br><span class=\"line\">        System.out.println(groups);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分组输出使用<code>Collectors.groupingBy()</code>，它需要提供两个函数：一个是分组的<code>key</code>，这里使用<code>s -&gt; s.substring(0, 1)</code>，表示只要首字母相同的<code>String</code>分到一组，第二个是分组的<code>value</code>，这里直接使用<code>Collectors.toList()</code>，表示输出为<code>List</code>，上述代码运行结果如下：</p>\n<blockquote>\n<p>A&#x3D;[Apple, Avocado, Apricots],<br>B&#x3D;[Banana, Blackberry],<br>C&#x3D;[Coconut, Cherry]  </p>\n</blockquote>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>Stream</code>提供的常用操作有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">转换操作</td>\n<td align=\"left\"><code>map()</code>，<code>filter()</code>，<code>sorted()</code>，<code>distinct()</code></td>\n</tr>\n<tr>\n<td align=\"left\">合并操作</td>\n<td align=\"left\"><code>concat()</code>，<code>flatMap()</code></td>\n</tr>\n<tr>\n<td align=\"left\">并行处理</td>\n<td align=\"left\"><code>parallel()</code></td>\n</tr>\n<tr>\n<td align=\"left\">聚合操作</td>\n<td align=\"left\"><code>reduce()</code>，<code>collect()</code>，<code>count()</code>，<code>max()</code>，<code>min()</code>，<code>sum()</code>，<code>average()</code></td>\n</tr>\n<tr>\n<td align=\"left\">其他操作</td>\n<td align=\"left\"><code>allMatch()</code>，<code>anyMatch()</code>，<code>forEach()</code></td>\n</tr>\n</tbody></table>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"需求规格\"><a href=\"#需求规格\" class=\"headerlink\" title=\"需求规格\"></a>需求规格</h2><p>在项目中，需要编写这样的业务逻辑：根据一串<code>id</code>在数据库中查询并返回与<code>id</code>匹配的数据；或者再复杂一些，在一个表中根据<code>id</code>查到数据，然后根据这些数据的其他字段查询另一个表的数据。在这些逻辑中，需要保证代码拥有较高的可读性和健壮性，保证数据库表或者<code>DTO</code>入参产生变化时，相应的业务代码不需要做大的改动。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>使用<code>Stream</code>代替<code>for</code>循环遍历数组，使用<code>map</code>可以从数据库表一行数据里提取出一个<code>id</code>字段，再用<code>collect</code>将其转换为<code>List</code>。</p>\n<p>使用<code>Stream</code>存储<code>id</code>时，如果用这些<code>id</code>查询到了多行数据，有可能会返回由<code>List</code>组成的<code>Stream</code>，这时就可以用<code>flatMap</code>，将它们转换成单行数据组成的<code>Stream</code>。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>假设已得到一个实体数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;EmissionCalcParamDTO&gt; emissionCalcParams</span><br></pre></td></tr></table></figure>\n\n<p>我们可以使用<code>Stream</code>轻松地获取这些实体的<code>id</code>，只需在<code>map</code>中传入<code>getter</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Long&gt; paramIdList = emissionCalcParams.stream()</span><br><span class=\"line\">        .map(EmissionCalcParamDTO::getId)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<p>之后，可以根据这些<code>id</code>在数据库中查询另一个表的数据，这里使用了MyBatis-Plus的条件构造器编写查询条件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;DetermineDTO&gt; determineList = <span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryChainWrapper</span>&lt;&gt;(determineMapper)</span><br><span class=\"line\">        .eq(DetermineDTO::getObtainingMethod, <span class=\"number\">2</span>)</span><br><span class=\"line\">        .in(DetermineDTO::getCalcParamId, paramIdList)</span><br><span class=\"line\">        .list();</span><br></pre></td></tr></table></figure>\n\n<p>最后，根据这些数据里的字段，返回第三个表的数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> determineList.stream()</span><br><span class=\"line\">        .map(DetermineDTO::getDeviceId)</span><br><span class=\"line\">        .map(<span class=\"built_in\">this</span>::getDeviceById)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<p>可以注意到，这些<code>map</code>传入了<code>getter</code>方法和内部方法，对<code>Stream</code>进行多次转换，最终得到我们想要的结果。</p>\n<p>再来看另一个实例。这次我们根据id获取到的数据是由<code>List</code>组成的，需要将它们转换成单行数据，即去除它们的分组。我们可以使用<code>flatMap</code>，把<code>Stream</code>的每个<code>List</code>映射为<code>Stream</code>，然后合并成一个新的<code>Stream</code>，只需传入<code>Collection</code>的内部方法<code>stream()</code>即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> deviceList.stream().map(MonitoringDeviceDTO::getId)</span><br><span class=\"line\">        .map(<span class=\"built_in\">this</span>::getRecordByDevice)</span><br><span class=\"line\">        .flatMap(Collection::stream)</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><p>我编写Java代码使用的<code>IDE</code>是<code>IntelliJ IDEA</code>。在编写<code>Stream</code>的链式操作时适当换行，<code>IDEA</code>可以将每一行链式操作得到的<strong>数据类型</strong>显示在行末，清晰地展现出<code>Stream</code>的<code>Pipelining</code>特点，非常有助于阅读和编写代码。</p>\n<p>此外，<code>IDEA</code>内置的<code>Lombok</code>插件（小辣椒）可以自动生成类的<code>getter</code>与<code>setter</code>方法，不需要手动重复编写，需要时直接调用就好，且代码自动补全功能会在这些自动生成的方法图标右下角显示一个小辣椒，非常有趣。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889\">使用Stream - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://www.runoob.com/java/java8-streams.html\">Java 8 Stream | 菜鸟教程</a></li>\n</ul>\n","categories":["学习笔记"],"tags":["Java","开发"]},{"title":"git rebase VS git merge？更优雅的Git合并方式值得拥有","url":"/posts/21df300fabde.html","content":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>你在使用Git合并分支时只会使用<code>git merge</code>吗？有时使用<code>git rebase</code>可以比<code>git merge</code>做出更优雅的操作。</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/hero.svg\" alt=\"合并与变基\"></p>\n<p>另外，如果你不能很好的应用Git，那么这里为你提供一个非常棒的Git在线练习工具：<a href=\"https://learngitbranching.js.org/\">Git Online</a>，你可以更直观的看到你所使用的命令会产生什么效果。</p>\n<h1 id=\"Merge与Rebase\"><a href=\"#Merge与Rebase\" class=\"headerlink\" title=\"Merge与Rebase\"></a>Merge与Rebase</h1><p>不知怎么，<code>git rebase</code>命令被赋予了一个神奇的污毒声誉，初学者应该远离它，但它实际上可以让开发团队在使用时更加轻松。</p>\n<blockquote>\n<p>你可以将它理解成「七伤拳」，「七伤拳」并不是不能练，只是练「七伤拳」有一个先诀条件，那就是内功境界一定要非常高，即你要充分理解<code>git rebase</code>命令。</p>\n</blockquote>\n<p>在本文中，我们将<code>git rebase</code>与<code>git merge</code>命令进行比较。在Git工作流中，说明所有可以使用Rebase的场景。</p>\n<h1 id=\"概念概述\"><a href=\"#概念概述\" class=\"headerlink\" title=\"概念概述\"></a>概念概述</h1><p>关于<code>git rebase</code>，首先要理解的是它解决了和<code>git merge</code>同样的问题。这两个命令都旨在将更改从一个分支合并到另一个分支，但二者的合并方式却有很大的不同。</p>\n<p>当你在专用分支上开发新feature时，另一个团队成员在<code>master</code>分支提交了新的commits，这会发生什么？这会导致分叉的历史记录。对于这个问题，使用Git作为协作工具的任何人来说都应该很熟悉。</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/01.svg\" alt=\"分叉的提交历史记录\"></p>\n<p>现在，假设在<code>master</code>分支上的新提交与你正在开发的feature相关。需要将新提交合并到你的<code>feature</code>分支中，你可以有两个选择：merge或者rebase。</p>\n<h2 id=\"Merge方式\"><a href=\"#Merge方式\" class=\"headerlink\" title=\"Merge方式\"></a>Merge方式</h2><p>最简单的方式是通过以下命令将<code>master</code>分支合并到<code>feature</code>分支中：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout feature</span><br><span class=\"line\">git merge master</span><br></pre></td></tr></table></figure>\n\n<p>或者，你可以将其浓缩为一行命令：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git merge feature master</span><br></pre></td></tr></table></figure>\n\n<p>这会在<code>feature</code>分支中创建一个新的<strong>merge commit</strong>，它将两个分支的历史联系在一起，请看如下所示的分支结构：</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/02.svg\" alt=\"将master分支合并到feature分支中\"></p>\n<p>使用merge是很好的方式，因为它是一种<strong>非破坏性</strong>的操作。现有分支不会以任何方式被更改，这避免了rebase操作所产生的潜在缺陷（下面讨论）。</p>\n<p>另一方面，这也意味着<code>feature</code>分支每次需要合并上游更改时，它都将产生一个额外的合并提交。如果<code>master</code>提交非常活跃，这可能会严重污染你的<code>feature</code>分支历史记录。尽管可以使用高级选项<code>git log</code>缓解此问题，但它可能使其他开发人员<strong>难以理解项目的历史记录</strong>。</p>\n<h2 id=\"Rebase方式\"><a href=\"#Rebase方式\" class=\"headerlink\" title=\"Rebase方式\"></a>Rebase方式</h2><p>作为merge的替代方法，你可以使用以下命令将<code>master</code>分支合并到<code>feature</code>分支上：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout feature</span><br><span class=\"line\">git rebase master</span><br></pre></td></tr></table></figure>\n\n<p>这会将整个<code>feature</code>分支移动到<code>master</code>分支的顶端，从而有效地整合了所有<code>master</code>分支上的提交。但是，与merge提交方式不同，rebase通过为原始分支中的每个提交创建全新的commits来<strong>重写</strong>项目历史记录。</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/03.svg\" alt=\"将feature分支rebase到master分支上\"></p>\n<p>rebase的主要好处是可以获得更清晰的项目历史。首先，它消除了<code>git merge</code>所需的不必要的合并提交；其次，正如你在上图中所看到的，rebase会产生完美线性的项目历史记录，你可以在<code>feature</code>分支上没有任何分叉的情况下一直追寻到项目的初始提交。这样可以通过命令<code>git log</code>，<code>git bisect</code>和<code>gitk</code>更容易地导航查看项目。</p>\n<p>但是，针对这样的提交历史我们需要权衡其「安全性」和「可追溯性」。如果你不遵循<strong>Rebase的黄金法则</strong>，重写项目历史记录可能会对你的协作工作流程造成灾难性后果。而且，rebase会丢失合并提交的上下文，你也就无法看到上游更改是何时合并到feature中的。</p>\n<h2 id=\"交互式Rebase\"><a href=\"#交互式Rebase\" class=\"headerlink\" title=\"交互式Rebase\"></a>交互式Rebase</h2><p>交互式rebase使你有机会在将commits移动到新分支时更改这些commits。这比自动rebase更强大，因为它提供了对分支提交历史的完全控制。通常，这用于在合并<code>feature</code>分支到 <code>master</code>之前清理其杂乱的历史记录。</p>\n<p>要使用交互式rebase，需要使用<code>git rebase</code>和<code>-i</code>选项：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout feature</span><br><span class=\"line\">git rebase <span class=\"literal\">-i</span> master</span><br></pre></td></tr></table></figure>\n\n<p>这将打开一个文本编辑器，列出即将移动的所有提交：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">pick <span class=\"number\">33</span>d5b7a Message <span class=\"keyword\">for</span> commit <span class=\"comment\">#1</span></span><br><span class=\"line\">pick <span class=\"number\">9480</span>b3d Message <span class=\"keyword\">for</span> commit <span class=\"comment\">#2</span></span><br><span class=\"line\">pick <span class=\"number\">5</span>c67e61 Message <span class=\"keyword\">for</span> commit <span class=\"comment\">#3</span></span><br></pre></td></tr></table></figure>\n\n<p>此列表准确定义了执行rebase后分支的外观。通过更改<code>pick</code>命令或重新排序条目，你可以使分支的历史记录看起来像你想要的任何内容。例如，如果第二次提交fix了第一次提交中的一个小问题，您可以使用以下<code>fixup</code>命令将它们浓缩为一个提交：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">pick <span class=\"number\">33</span>d5b7a Message <span class=\"keyword\">for</span> commit <span class=\"comment\">#1</span></span><br><span class=\"line\">fixup <span class=\"number\">9480</span>b3d Message <span class=\"keyword\">for</span> commit <span class=\"comment\">#2</span></span><br><span class=\"line\">pick <span class=\"number\">5</span>c67e61 Message <span class=\"keyword\">for</span> commit <span class=\"comment\">#3</span></span><br></pre></td></tr></table></figure>\n\n<p>保存并关闭文件时，Git将根据您的指示执行rebase，从而产生如下所示的项目历史记录：</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/04.svg\" alt=\"使用交互式rebase来压缩提交\"></p>\n<p>消除这种无意义的提交使你的功能历史更容易理解。这是<code>git merge</code>根本无法做到的事情。至于commits条目前的<code>pick</code>、<code>fixup</code>、<code>squash</code>等命令，在Git目录执行<code>git rebase -i</code>即可查看到，大家按需重排或合并提交即可，注释说明非常清晰，在此不做过多说明。</p>\n<h1 id=\"Rebase的黄金法则\"><a href=\"#Rebase的黄金法则\" class=\"headerlink\" title=\"Rebase的黄金法则\"></a>Rebase的黄金法则</h1><p>一旦你理解了什么是rebase，最重要的是要学习什么时候不能使用它。<code>git rebase</code>的黄金法则是永远不要在公共分支上使用它。</p>\n<p>例如，想想如果你rebase<code>master</code>分支到<code>feature</code>分支之上会发生什么：</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/05.svg\" alt=\"Rebase到主分支\"></p>\n<p>rebase将所有<code>master</code>分支上的提交移动 feature 分支的顶端。问题是这只发生在<strong>你自己</strong>的存储库中。所有其他开发人员仍在使用原始版本的<code>master</code>。由于rebase产生了全新 commit，Git会认为你的<code>master</code>分支历史与其他人的历史不同。</p>\n<p>此时，同步两个<code>master</code>分支的唯一方法是将它们合并在一起，但是这样会产生额外的合并提交和两组包含相同更改的提交（原始提交和通过rebase更改的分支提交）。不用说，这是一个令人非常困惑的情况。</p>\n<p>因此，在你运行<code>git rebase</code>命令之前，总是问自己，<strong>还有其他人在用这个分支吗？</strong> 如果答案是肯定的，那就把你的手从键盘上移开，开始考虑采用非破坏性的方式进行改变（例如<code>git revert</code>命令）。否则，你可以随心所欲地重写历史记录。</p>\n<h2 id=\"Force-Push\"><a href=\"#Force-Push\" class=\"headerlink\" title=\"Force Push\"></a>Force Push</h2><p>如果你尝试将rebase了的<code>master</code>分支推送回remote repository，Git将阻止你这样做，因为它会与远程<code>master</code>分支冲突。但是，你可以通过传递<code>--force</code>标志来强制推送，如下所示：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Be very careful with this command!</span></span><br><span class=\"line\">git push <span class=\"literal\">--force</span></span><br></pre></td></tr></table></figure>\n\n<p>这样你自己repository的内容将覆盖远程<code>master</code>分支的内容，但这会使团队的其他成员感到困惑。因此，只有在确切知道自己在做什么时才要非常小心地使用此命令。</p>\n<p>如果没有人在feature分支上作出更改，你可以使用force push将本地内容推送到remote repository做清理工作。</p>\n<h1 id=\"工作流程演练\"><a href=\"#工作流程演练\" class=\"headerlink\" title=\"工作流程演练\"></a>工作流程演练</h1><p>rebase可以根据你所在团队的需要方便的整合到现有的Git工作流程中。在本节中，我们将了解rebase在功能开发的各个阶段可以提供的好处。</p>\n<p>在任何工作流程中，利用<code>git rebase</code>是为每个功能创建专用分支。这为你提供了必要的分支，以安全地利用rebase：</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/06.svg\" alt=\"在专用分支中开发功能\"></p>\n<h2 id=\"本地清理\"><a href=\"#本地清理\" class=\"headerlink\" title=\"本地清理\"></a>本地清理</h2><p>将rebase纳入工作流程的最佳方法之一是清理本地正在进行的功能。通过定期执行交互式rebase，你可以确保功能中的每个提交都具有针对性和意义。这可以使你在编写代码时无需担心将其分解为隔离的提交（多个提交），你可以在事后修复整合它。</p>\n<p>使用<code>git rebase</code>时，有两种情况：<code>feature</code>父分支（例如<code>master</code>）的提交，或在<code>feature</code>中的早期提交。我们在<strong>交互式 Rebase</strong>部分已经介绍了第一种情况的示例。我们来看后一种情况，当你只需要修复最后几次提交时，以下命令仅做最后<code>3</code>次提交的交互式rebase。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout feature</span><br><span class=\"line\">git rebase <span class=\"literal\">-i</span> HEAD~<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<p>通过指定<code>HEAD~3</code>，你实际上并没有移动分支，你只是交互式地重写其后的<code>3</code>个提交。请注意，这<strong>不会</strong>将上游更改合并到<code>feature</code>分支中。</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/07.svg\" alt=\"Rebase到HEAD~3\"></p>\n<p>如果要使用此方法重写整个功能，<code>git merge-base</code>命令可用于查找<code>feature</code>分支的原始base。以下内容返回原始base的提交ID，然后你可以将其传递给<code>git rebase</code>：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">merge-base</span> feature master</span><br></pre></td></tr></table></figure>\n\n<p>交互式rebase的使用是引入<code>git rebase</code>工作流的好方法，因为它只影响本地分支。其他开发人员唯一能看到的就是你提交的最终版，这应该是一个简洁易懂易跟踪的分支历史记录。</p>\n<p>但同样，这仅适用于私有<code>feature</code>分支。如果你通过相同的功能分支(公共分支)与其他开发人员协作，那么你是<strong>不被允许</strong>重写其历史记录的。</p>\n<h2 id=\"将上游更改合并到功能分支中\"><a href=\"#将上游更改合并到功能分支中\" class=\"headerlink\" title=\"将上游更改合并到功能分支中\"></a>将上游更改合并到功能分支中</h2><p>在<strong>概念概述</strong>部分中，我们了解了<code>feature</code>分支可以使用<code>git merge</code>或<code>git rebase</code>合并<code>master</code>分支的上游更改。merge是一个安全的方式，可以保留git repository的整个历史记录，而rebase则是通过将<code>feature</code>分支移动到<code>master</code>顶端来创建线性历史记录。</p>\n<p>这种使用<code>git rebase</code>类似于本地清理，但在此过程中它包含了那些来自master上游的提交。</p>\n<p>请记住，将当前提交rebase到远程branch（非master分支）一样是合法的。当与另一个开发人员协作使用相同的功能并且你需要将他们的更改合并到你的repository时，就会发生这种情况。</p>\n<p>例如，如果你和另一个名为John的开发人员添加了对<code>feature</code>分支的提交，在你fetch（注意fetch并不会自动merge）来自John的远程<code>feature</code>分支后，你的repository可能如下所示：</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/08.svg\" alt=\"在同一个feature分支上进行协作\"></p>\n<p>你可以合并来自上游的分叉：要么用<code>john/feature</code><strong>merge</strong>本地<code>feature</code>，要么<strong>rebase</strong>本地<code>feature</code>到<code>john/feature</code>的顶部。</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/09.svg\" alt=\"合并与变基到远程分支\"></p>\n<p>请注意，此rebase不违反<strong>Rebase 黄金规则</strong>，因为只有你的本地<code>feature</code>提交被移动，之前的所有内容都不会受到影响。这就像是说「将我的更改添加到John已经完成的工作中」。在大多数情况下，这比通过合并提交与远程分支同步更直观。</p>\n<p>默认情况下，使用<code>git pull</code>命令执行合并，但你可以通过向其传递<code>--rebase</code>选项来强制它将远程分支以rebase方式集成。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git pull <span class=\"literal\">--rebase</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用Pull请求Review-Feature\"><a href=\"#使用Pull请求Review-Feature\" class=\"headerlink\" title=\"使用Pull请求Review Feature\"></a>使用Pull请求Review Feature</h2><p>如果你在代码审查过程中使用pull请求，在使用了pull请求之后你应该避免使用<code>git rebase</code>。一旦你发出pull请求，其他开发人员就会查看你的提交，这意味着它是一个<strong>公共</strong>分支。重写其历史记录将使Git和你的队友无法跟踪添加到该功能的任何后续提交。</p>\n<p>其他开发人员的任何更改都需要合并<code>git merge</code>而不是<code>git rebase</code>。</p>\n<p>因此，在提交拉取请求之前，通常使用交互式rebase清理代码是个好的办法。注意使用顺序。</p>\n<h2 id=\"集成已批准的功能\"><a href=\"#集成已批准的功能\" class=\"headerlink\" title=\"集成已批准的功能\"></a>集成已批准的功能</h2><p>在你的团队批准某项feature后，你可以选择将该功能rebase到<code>master</code>分支的顶端，然后<code>git merge</code>再将该功能集成到主代码库中。</p>\n<p>这与将上游更改合并到feature分支中的情况类似，但由于你不允许在<code>master</code>分支中重写提交，因此你必须最终使用<code>git merge</code>该功能进行集成。但是，通过在merge之前执行rebase，你可以确保会以<code>fast-forward</code>方式merge，从而产生完美的线性历史记录。</p>\n<blockquote>\n<p><code>fast-forward</code>指的是merge之后不会出现新的commit对象，分支的合并线是一条直线，被合并的分支，没有分叉，会丢失，再看不到该分支历史。相对地，<code>no-fast-forward</code>方式merge之后会出现一个merge commit对象，分支的合并线在主干外出现一条分叉，在merge节点处合并为主干。</p>\n</blockquote>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/git-merge-and-rebase/10.svg\" alt=\"使用和不使用rebase将feature集成到master中\"></p>\n<p>如果您不熟悉<code>git rebase</code>，可以随时在临时分支中执行rebase。这样，如果你不小心弄乱了功能的历史记录，可以查看原始分支，然后重试。例如：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout feature</span><br><span class=\"line\">git checkout <span class=\"literal\">-b</span> temporary<span class=\"literal\">-branch</span></span><br><span class=\"line\">git rebase <span class=\"literal\">-i</span> master</span><br><span class=\"line\"><span class=\"comment\"># [Clean up the history]</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge temporary<span class=\"literal\">-branch</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>如果你更喜欢没有不必要的干净的合并提交，线性历史记录，你就需要开始了解使用rebase功能。同时你应该使用<code>git rebase</code>而不是<code>git merge</code>集成来自另一个分支的更改。</p>\n<p>另一方面，如果你想保留项目的完整历史记录并避免重写公共提交的风险，你可以坚持使用<code>git merge</code>。这两种选择都是完全有效的，但至少现在你可以选择利用<code>git rebase</code>的好处 。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>本文转自公众号「日拱一兵」的文章<a href=\"https://www.cnblogs.com/FraserYu/p/11192840.html\">git rebase VS git merge？更优雅的git合并方式值得拥有</a></p>\n","categories":["经验分享"],"tags":["Git"]},{"title":"helloworld","url":"/posts/bce9a85f8d8c.html","content":"<h1 id=\"你好！\"><a href=\"#你好！\" class=\"headerlink\" title=\"你好！\"></a>你好！</h1><p>这是我的第一篇博客。</p>\n<h1 id=\"Hello\"><a href=\"#Hello\" class=\"headerlink\" title=\"Hello!\"></a>Hello!</h1><p>This is my first blog.</p>\n","categories":["杂谈"]},{"title":"PO、VO、DAO、BO、POJO一脸懵？一张图给你解释清楚","url":"/posts/808dabf0f098.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>《阿里巴巴Java开发规范》关于领域模型的部分介绍如下：</p>\n<h2 id=\"分层领域模型规约\"><a href=\"#分层领域模型规约\" class=\"headerlink\" title=\"分层领域模型规约\"></a>分层领域模型规约</h2><ul>\n<li><dl><dt>DO(Data Object)</dt><dd>此对象的属性与数据库表结构一一对应，通过<code>DAO</code>层向上传输数据源对象。</dd></dl></li>\n<li><dl><dt>DTO(Data Transfer Object)</dt><dd>数据传输对象，<code>Service</code>或<code>Manager</code>向外传输的对象。</dd></dl></li>\n<li><dl><dt>BO(Business Object)</dt><dd>业务对象，由<code>Service</code>层输出的封装业务逻辑的对象。</dd></dl></li>\n<li><dl><dt>AO(ApplicationObject)</dt><dd>应用对象，在<code>Web</code>层与<code>Service</code>层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</dd></dl></li>\n<li><dl><dt>VO(View Object)</dt><dd>显示层对象，通常是<code>Web</code>层向模板渲染引擎层传输的对象。</dd></dl></li>\n<li><dl><dt>Query</dt><dd>数据查询对象，各层接收上层的查询请求。注意超过<code>2</code>个参数的查询封装，禁止使用<code>Map</code>类来传输。</dd></dl></li>\n</ul>\n<h2 id=\"领域模型命名规约\"><a href=\"#领域模型命名规约\" class=\"headerlink\" title=\"领域模型命名规约\"></a>领域模型命名规约</h2><ul>\n<li><dl><dt>数据对象</dt><dd><code>xxxDO</code>，<code>xxx</code>即为数据表名。</dd></dl></li>\n<li><dl><dt>数据传输对象</dt><dd><code>xxxDTO</code>，<code>xxx</code>为业务领域相关的名称。</dd></dl></li>\n<li><dl><dt>展示对象</dt><dd><code>xxxVO</code>，<code>xxx</code>一般为网页名称。</dd></dl></li>\n<li><p><code>POJO</code>是<code>DO/DTO/BO/VO</code>的统称，禁止命名成<code>xxxPOJO</code>。</p>\n</li>\n</ul>\n<p>先看一张各个对象间的关系图，有个印象：</p>\n<p><img src=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/image/post/java-beans/java-beans.webp\" alt=\"Java Bean关系图\"></p>\n<p>然后，再来慢慢解释各个对象的作用。</p>\n<h1 id=\"Java-Bean\"><a href=\"#Java-Bean\" class=\"headerlink\" title=\"Java Bean\"></a>Java Bean</h1><h2 id=\"VO\"><a href=\"#VO\" class=\"headerlink\" title=\"VO\"></a>VO</h2><blockquote>\n<p>View Object的缩写</p>\n</blockquote>\n<p>用于表示前端的展示对象；相比与<code>PO</code>（数据库映射对象），<code>VO</code>对象与前端交互的数据可能需要经过过滤、拆分、聚合等操作；比方说部分不需要展示的数据，<code>VO</code>层将其剔除后返回；如果数据来源于多个地方，也将会在<code>VO</code>对象进行聚合再返回。</p>\n<p>遵循Java Bean的规范，其拥有<code>Getter/Setter</code>方法。</p>\n<h2 id=\"DTO\"><a href=\"#DTO\" class=\"headerlink\" title=\"DTO\"></a>DTO</h2><blockquote>\n<p>Data Transfer Object的缩写</p>\n</blockquote>\n<p>数据传输对象；<code>DTO</code>主要协调于各个服务之间，用于数据的转换和传输；比如，数据库有<code>20</code>个字段，但实际业务只需要<code>5</code>个，那么就可以借助<code>DTO</code>对<code>PO</code>对象进行传输；避免数据库结构的暴露，并减少不必要的数据交互。</p>\n<p>遵循Java Bean的规范，其拥有<code>Getter/Setter</code>方法。</p>\n<h2 id=\"BO\"><a href=\"#BO\" class=\"headerlink\" title=\"BO\"></a>BO</h2><blockquote>\n<p>Business Object的缩写</p>\n</blockquote>\n<p>表示一个业务对象；<code>BO</code>包含了一些业务逻辑，通常用于封装对<code>DAO</code>、<code>RPC</code>等相关的调用，同时还可以进行<code>PO</code>、<code>VO</code>、<code>DTO</code>之间的数据转换；</p>\n<p><code>BO</code>通常都是位于业务层，并提供了基本的业务操作；在设计上属于被服务层业务逻辑调用的对象，一段业务的执行，可能需要多个<code>BO</code>对象的相互配合才能完成。</p>\n<h2 id=\"PO\"><a href=\"#PO\" class=\"headerlink\" title=\"PO\"></a>PO</h2><blockquote>\n<p>Persistent Object的缩写</p>\n</blockquote>\n<p>表示着Java对象与数据库之间的映射关系；其仅用于表示数据，并没有任何的数据操作；</p>\n<p>遵循Java Bean的规范，其拥有<code>Getter/Setter</code>方法。</p>\n<h2 id=\"DAO\"><a href=\"#DAO\" class=\"headerlink\" title=\"DAO\"></a>DAO</h2><blockquote>\n<p>Data Access Object的缩写</p>\n</blockquote>\n<p>通过<code>DAO</code>配合<code>PO</code>对象进行数据库访问，其中包含了增删改查等一系列的数据库操作，<code>DAO</code>一般在持久层，其完全封装了数据库的行为，并对外提供方法，上层通过它访问数据完全不需要关心数据库的任何信息。</p>\n<h2 id=\"POJO\"><a href=\"#POJO\" class=\"headerlink\" title=\"POJO\"></a>POJO</h2><blockquote>\n<p>Plain Ordinary Java Object的缩写</p>\n</blockquote>\n<p>表示一个简单Java对象；一个Java类只要遵循Java Bean的规范，并赋予<code>Getter/Setter</code>方法，就是一个<code>POJO</code>；</p>\n<p>只是在不用的场景，不同的功能和定义下，<code>POJO</code>会演变为<code>PO</code>、<code>VO</code>、<code>DTO</code>等。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>本文转自微信公众号「一行Java」</p>\n","categories":["经验分享"],"tags":["Java"]},{"title":"初识MyBatis-Plus","url":"/posts/6a03ebbdc425.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在前面的Java学习笔记中，我提到过两次<code>MyBatis-Plus</code>，可能大家已经对这个名词有些耳熟。我对它的定义是：一个方便的操作数据库功能的工具包。</p>\n<p>在它的官方文档上写道：<code>MyBatis-Plus</code>是一个<code>MyBatis</code>的增强工具，在<code>MyBatis</code>的基础上<strong>只做增强不做改变</strong>，为简化开发、提高效率而生。<code>MyBatis</code>与<code>MyBatis-Plus</code>都是<code>ORM</code>框架（<em>对象-关系映射框架</em>），对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为<strong>对象</strong>，在数据库中表现为<strong>关系数据</strong>。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射框架(<code>ORM</code>)一般以中间件的形式存在，主要实现对象到关系数据库数据的映射。</p>\n<p>当我们编写一个应用程序时，我们可能会写特别多数据访问层的代码，从数据库添加、删除、读取对象信息，而这些代码都是重复的，如果使用<code>ORM</code>则会大大减少重复性代码。在使用<code>MyBatis-Plus</code>的时候，我总是为之惊叹：原来数据库操作能这么简单！于是我写下这篇文章记录它的一些使用方法。</p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><p>将<code>MyBatis-Plus</code>引入<code>Spring</code>项目非常容易，网上有许多实例，在此不做讲解。接下来，我主要介绍如何使用<code>MyBatis-Plus</code>的条件构造器编写业务逻辑。大体上，<code>MyBatis-Plus</code>从数据库表到前端接口的业务流程是<code>数据库表-&gt;DTO-&gt;Mapper-&gt;Service-&gt;Controller</code>，因此，我将顺着这条流程依次讲解每个环节要使用<code>MyBatis-Plus</code>编写哪些代码。</p>\n<h2 id=\"数据库表\"><a href=\"#数据库表\" class=\"headerlink\" title=\"数据库表\"></a>数据库表</h2><p>我以一个存储测量设备的数据库表为例，编写与它相关的增删改查接口。下面是它的表结构：</p>\n<blockquote>\n<p>MonitoringDevice</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>数据类型</th>\n<th>注释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>bigint</td>\n<td>设备id</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar</td>\n<td>设备名</td>\n</tr>\n<tr>\n<td>model</td>\n<td>varchar</td>\n<td>设备型号</td>\n</tr>\n<tr>\n<td>type</td>\n<td>varchar</td>\n<td>设备类型</td>\n</tr>\n<tr>\n<td>illustrate</td>\n<td>varchar</td>\n<td>说明</td>\n</tr>\n<tr>\n<td>location</td>\n<td>varchar</td>\n<td>设备位置</td>\n</tr>\n<tr>\n<td>accuracy</td>\n<td>varchar</td>\n<td>测量精度</td>\n</tr>\n<tr>\n<td>frequency</td>\n<td>varchar</td>\n<td>校正频率</td>\n</tr>\n</tbody></table>\n<p>此外，还有一些与该表存在关联的其他数据表，主要通过<strong>外键</strong>与其关联，在此不做举例。</p>\n<h2 id=\"DTO\"><a href=\"#DTO\" class=\"headerlink\" title=\"DTO\"></a>DTO</h2><p><code>DTO</code>即数据传输对象，是数据从后端传输到前端的载体。大体上，一个<code>DTO</code>要包含一个数据库表的部分或所有字段信息。为了减少重复代码，我将这些表的重复字段单列出一个<code>ModelDTO</code>，让其他的<code>DTO</code>继承这个<code>ModelDTO</code>。建议使用<code>Lombok</code>插件提供的<code>@Data</code>注解，可以为<code>DTO</code>的私有成员自动生成<code>getter</code>和<code>setter</code>方法。</p>\n<blockquote>\n<p>ModelDTO.java</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ModelDTO</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>MonitoringDeviceDTO.java</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EqualsAndHashCode(callSuper = true)</span></span><br><span class=\"line\"><span class=\"meta\">@TableName(&quot;monitoringdevice&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MonitoringDeviceDTO</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ModelDTO</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String model;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String type;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String illustrate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String location;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String accuracy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String frequency;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Mapper\"><a href=\"#Mapper\" class=\"headerlink\" title=\"Mapper\"></a>Mapper</h2><p><code>Mapper</code>的编写非常简单，只需继承<code>BaseMapper</code>即可，以<code>MonitoringDeviceMapper</code>为例：</p>\n<blockquote>\n<p>MonitoringDeviceMapper.java</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Mapper</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MonitoringDeviceMapper</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BaseMapper</span>&lt;MonitoringDeviceDTO&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Service\"><a href=\"#Service\" class=\"headerlink\" title=\"Service\"></a>Service</h2><p>事实上，这些<code>Mapper</code>继承<code>BaseMapper</code>后已经为我们提供了默认的<code>CRUD</code>接口和一些默认方法。当这些接口和方法不满足我们需要的功能时，就需要自行编写<code>Service</code>。</p>\n<blockquote>\n<p><code>CRUD</code>是指做计算处理时的增加(<code>Create</code>)、读取查询(<code>Retrieve</code>)、更新(<code>Update</code>)和删除(<code>Delete</code>)几个单词的首字母简写。代表了数据库或持久层的基本操作功能。</p>\n</blockquote>\n<p>定义<code>Service</code>类时，在私有变量<code>Mapper</code>前加上<code>@Autowired</code>注解。</p>\n<blockquote>\n<p>MonitoringDeviceService.java</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MonitoringDeviceService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MonitoringDeviceMapper monitoringDeviceMapper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加和编辑数据\"><a href=\"#增加和编辑数据\" class=\"headerlink\" title=\"增加和编辑数据\"></a>增加和编辑数据</h3><p>首先是增加和编辑数据的逻辑。这里为了便于维护代码，我定义了<code>RequestBody</code>作为两个方法的入参。</p>\n<p>在增加方法中，我添加了判断入参字段是否合法的逻辑，然后调用<code>insert()</code>方法插入一行数据。</p>\n<p>由于<code>DTO</code>与<code>RequestBody</code>都是<code>JavaBean</code>，可以使用<code>BeanUtils</code>的<code>copyProperties()</code>方法将<code>RequestBody</code>的参数复制给<code>DTO</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Boolean <span class=\"title function_\">addDevice</span><span class=\"params\">(AddMonitoringDeviceReq device)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!DetermineEnum.isInclude(device.getType())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ParamException</span>(<span class=\"string\">&quot;参数不支持&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">MonitoringDeviceDTO</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MonitoringDeviceDTO</span>();</span><br><span class=\"line\">    BeanUtils.copyProperties(device, instance);</span><br><span class=\"line\">    monitoringDeviceMapper.insert(instance);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在编辑方法中，使用链式条件构造器<code>LambdaQueryChainWrapper</code>根据传入的实体<code>id</code>查询<code>Device</code>表中是否有对应的数据，<code>eq()</code>定义了一个相等条件进行查询，再使用<code>exists()</code>方法返回布尔值，以判断查询到的数据是否存在，最后调用<code>insert()</code>方法即可。</p>\n<blockquote>\n<p>注意：<code>insert()</code>会自动根据数据是否存在，即插入的是否为重复行，若不存在则新增一条数据，若存在则编辑该条数据。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> MonitoringDeviceDTO <span class=\"title function_\">editDevice</span><span class=\"params\">(EditMonitoringDeviceReq device)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">exists</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryChainWrapper</span>&lt;&gt;(monitoringDeviceMapper)</span><br><span class=\"line\">            .eq(MonitoringDeviceDTO::getId, device.getId()).exists();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!exists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NotFoundException</span>(<span class=\"string\">&quot;设备不存在&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">MonitoringDeviceDTO</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MonitoringDeviceDTO</span>();</span><br><span class=\"line\">    BeanUtils.copyProperties(device, instance);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> monitoringDeviceMapper.insert(instance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h3><p>然后是查询数据的逻辑。首先是最简单的根据<code>id</code>获取数据，只需调用<code>selectById()</code>默认方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> MonitoringDeviceDTO <span class=\"title function_\">getDeviceById</span><span class=\"params\">(Long deviceId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Objects.isNull(deviceId)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> monitoringDeviceMapper.selectById(deviceId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后是根据<code>Determine</code>表的字段查询数据。由于<code>Determine</code>表是通过外键<code>deviceId</code>与该表的<code>id</code>进行关联的，要查询<code>Device</code>表的数据，首先要获得<code>Determine</code>表的<code>deviceId</code>字段，按照这个逻辑编写条件构造器即可，使用<code>one()</code>返回一行数据，之后调用前面的<code>getDeviceById()</code>方法，传入获得的<code>deviceId</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> MonitoringDeviceDTO <span class=\"title function_\">getDeviceByParamId</span><span class=\"params\">(Long paramId)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Objects.isNull(paramId)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getDeviceById(<span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryChainWrapper</span>&lt;&gt;(determineMapper)</span><br><span class=\"line\">            .eq(DetermineDTO::getCalcParamId, paramId)</span><br><span class=\"line\">            .one().getDeviceId());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后是根据设备类型批量获取数据，同样使用<code>eq()</code>定义相等查询条件，使用<code>list()</code>返回多行数据，以<code>list</code>数组的形式作为返回值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;MonitoringDeviceDTO&gt; <span class=\"title function_\">getDeviceByType</span><span class=\"params\">(String type)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!DetermineEnum.isInclude(type)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ParamException</span>(<span class=\"string\">&quot;类型不支持&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryChainWrapper</span>&lt;&gt;(monitoringDeviceMapper)</span><br><span class=\"line\">            .eq(MonitoringDeviceDTO::getType, type).list();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是一个相对复杂的多表联合查询的方法。根据<code>Source</code>表的<code>id</code>获取与之关联的若干个<code>CalcParam</code>，再依次获取这些<code>CalcParam</code>的id，存入<code>paramIdList</code>，然后在<code>Determine</code>表中查询<code>ObtainingMethod</code>字段为2、且<code>CalcParamId</code>与刚才<code>paramIdList</code>匹配的数据行，最后根据这些<code>Determine</code>获取设备。</p>\n<p>在上面这串逻辑中，除了前面提到的<code>eq()</code>相等条件外，还使用到了<code>in()</code>匹配字段条件，并在其中穿插使用<code>Stream</code>处理和转换数据，是一次<code>MyBatis-Plus</code>与<code>Stream</code>的综合运用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;MonitoringDeviceDTO&gt; <span class=\"title function_\">getDeviceBySource</span><span class=\"params\">(Long sourceId)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">exists</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryChainWrapper</span>&lt;&gt;(emissionSourceMapper)</span><br><span class=\"line\">            .eq(EmissionSourceDTO::getId, sourceId).exists();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!exists) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NotFoundException</span>(<span class=\"string\">&quot;数据不存在&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;EmissionCalcParamDTO&gt; emissionCalcParams = emissionSourceCalcParamMapper</span><br><span class=\"line\">            .selectList(<span class=\"keyword\">new</span> <span class=\"title class_\">QueryWrapper</span>&lt;&gt;(EmissionCalcParamDTO.class)</span><br><span class=\"line\">                    .treeNode(ModelLabelConstant.EMISSION_SOURCE, sourceId));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(emissionCalcParams)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultCarbonException</span>(<span class=\"string\">&quot;参数异常&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Long&gt; paramIdList = emissionCalcParams.stream()</span><br><span class=\"line\">            .map(EmissionCalcParamDTO::getId)</span><br><span class=\"line\">            .collect(Collectors.toList());</span><br><span class=\"line\">    List&lt;DetermineDTO&gt; determineList = <span class=\"keyword\">new</span> <span class=\"title class_\">LambdaQueryChainWrapper</span>&lt;&gt;(determineMapper)</span><br><span class=\"line\">            .eq(DetermineDTO::getObtainingMethod, <span class=\"number\">2</span>)</span><br><span class=\"line\">            .in(DetermineDTO::getCalcParamId, paramIdList)</span><br><span class=\"line\">            .list();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> determineList.stream()</span><br><span class=\"line\">            .map(DetermineDTO::getDeviceId)</span><br><span class=\"line\">            .map(<span class=\"built_in\">this</span>::getDeviceById)</span><br><span class=\"line\">            .collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h3><p>最后是删除数据的逻辑，删除<code>Device</code>表的数据同时要删除与其关联的<code>MaintenanceRecord</code>表数据，先根据id查询<code>MaintenanceRecord</code>表中拥有与之相同的<code>deviceId</code>外键的数据，再转换成<code>id</code>，使用<code>deleteBatchIds()</code>方法批量删除即可，最后调用<code>deleteById()</code>方法删除设备。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Boolean <span class=\"title function_\">deleteDevice</span><span class=\"params\">(Long deviceId)</span> &#123;</span><br><span class=\"line\">    List&lt;MaintenanceRecordDTO&gt; records = maintenanceRecordService.getRecordByDeviceId(deviceId);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(records)) &#123;</span><br><span class=\"line\">        monitoringDeviceMapper.deleteBatchIds(records.stream()</span><br><span class=\"line\">                .map(MaintenanceRecordDTO::getId)</span><br><span class=\"line\">                .collect(Collectors.toList()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> monitoringDeviceMapper.deleteById(deviceId) == <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><p>一般使用<code>Spring</code>框架的<code>RestController</code>向前端提供接口，根据不同的接口类型添加<code>@PostMapping</code>、<code>@GetMapping</code>等注解。同时通过<code>Swagger UI</code>展示和调试接口。</p>\n<blockquote>\n<p>MonitoringDeviceController.java</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;demo/device&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Api(value = &quot;demo/device&quot;, tags = &quot;测量设备接口&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MonitoringDeviceController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MonitoringDeviceService deviceService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping(&quot;add&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(value = &quot;新增设备&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result&lt;Boolean&gt; <span class=\"title function_\">addDevice</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Validated</span> AddMonitoringDeviceReq device)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.ok(deviceService.addDevice(device));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping(&quot;edit&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(value = &quot;编辑设备&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result&lt;MonitoringDeviceDTO&gt; <span class=\"title function_\">editDevice</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> EditMonitoringDeviceReq device)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.ok(deviceService.editDevice(device));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;getById&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(value = &quot;获取设备&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result&lt;MonitoringDeviceDTO&gt; <span class=\"title function_\">getDeviceById</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> Long deviceId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.ok(deviceService.getDeviceById(deviceId));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping(&quot;delete&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ApiOperation(value = &quot;删除设备&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Result&lt;Boolean&gt; <span class=\"title function_\">deleteDevice</span><span class=\"params\">(<span class=\"meta\">@RequestParam</span> Long deviceId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.ok(deviceService.deleteDevice(deviceId));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"条件构造器的其他方法\"><a href=\"#条件构造器的其他方法\" class=\"headerlink\" title=\"条件构造器的其他方法\"></a>条件构造器的其他方法</h1><table>\n<thead>\n<tr>\n<th align=\"left\">方法名</th>\n<th align=\"left\">SQL</th>\n<th align=\"left\">实例</th>\n<th align=\"left\">SQL实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">eq</td>\n<td align=\"left\">等于&#x3D;</td>\n<td align=\"left\">eq(“name”, “老王)</td>\n<td align=\"left\">name &#x3D; ‘老王’</td>\n</tr>\n<tr>\n<td align=\"left\">ne</td>\n<td align=\"left\">不等于&lt;&gt;</td>\n<td align=\"left\">ne(“name”, “老王)</td>\n<td align=\"left\">name &lt;&gt; ‘老王’</td>\n</tr>\n<tr>\n<td align=\"left\">gt</td>\n<td align=\"left\">大于&gt;</td>\n<td align=\"left\">gt(“age”, 18)</td>\n<td align=\"left\">age &gt; 18</td>\n</tr>\n<tr>\n<td align=\"left\">e</td>\n<td align=\"left\">大于等于&gt;&#x3D;</td>\n<td align=\"left\">ge(“age”, 18)</td>\n<td align=\"left\">age &gt;&#x3D; 18</td>\n</tr>\n<tr>\n<td align=\"left\">t</td>\n<td align=\"left\">小于&lt;</td>\n<td align=\"left\">It(“age”, 18)</td>\n<td align=\"left\">age &lt; 18</td>\n</tr>\n<tr>\n<td align=\"left\">e</td>\n<td align=\"left\">小于&lt;&#x3D;</td>\n<td align=\"left\">le(“age”, 18)</td>\n<td align=\"left\">age &lt;&#x3D; 18</td>\n</tr>\n<tr>\n<td align=\"left\">between</td>\n<td align=\"left\">BETWEEN 值1 AND 值2</td>\n<td align=\"left\">between(“age”, 18, 30)</td>\n<td align=\"left\">age between 18 and 30</td>\n</tr>\n<tr>\n<td align=\"left\">notBetween</td>\n<td align=\"left\">NOT BETWEEN 值1 AND 值2</td>\n<td align=\"left\">notBetween(“age”, 18, 30)</td>\n<td align=\"left\">age not between 18 and 30</td>\n</tr>\n<tr>\n<td align=\"left\">like</td>\n<td align=\"left\">LIKE ‘%值%’</td>\n<td align=\"left\">like(“name”, “王”)</td>\n<td align=\"left\">name like ‘%王%’</td>\n</tr>\n<tr>\n<td align=\"left\">notLike</td>\n<td align=\"left\">NOT LIKE ‘%值%’</td>\n<td align=\"left\">notLike(“name”, “王”)</td>\n<td align=\"left\">name not like ‘%王%’</td>\n</tr>\n<tr>\n<td align=\"left\">likeLeft</td>\n<td align=\"left\">LIKE ‘%值’</td>\n<td align=\"left\">likeLeft(“name”, “王”)</td>\n<td align=\"left\">name like ‘%王’</td>\n</tr>\n<tr>\n<td align=\"left\">likeRight</td>\n<td align=\"left\">LIKE ‘值%’</td>\n<td align=\"left\">likeRight(“name”, “王”)</td>\n<td align=\"left\">name like ‘王%’</td>\n</tr>\n<tr>\n<td align=\"left\">isNull</td>\n<td align=\"left\">字段 IS NULL</td>\n<td align=\"left\">isNull(“name”)</td>\n<td align=\"left\">name is null</td>\n</tr>\n<tr>\n<td align=\"left\">isNotNull</td>\n<td align=\"left\">字段 IS NOT NULL</td>\n<td align=\"left\">isNotNull(“name”)</td>\n<td align=\"left\">name is not null</td>\n</tr>\n<tr>\n<td align=\"left\">in</td>\n<td align=\"left\">字段 IN (v0, v1, …)</td>\n<td align=\"left\">in(“age”, {1, 2, 3})</td>\n<td align=\"left\">age in (1, 2, 3)</td>\n</tr>\n<tr>\n<td align=\"left\">notIn</td>\n<td align=\"left\">字段 NOT IN (v0, v1, …)</td>\n<td align=\"left\">notIn(“age”, {1, 2, 3})</td>\n<td align=\"left\">age not in (1, 2, 3)</td>\n</tr>\n<tr>\n<td align=\"left\">inSql</td>\n<td align=\"left\">字段 IN(sql语句)</td>\n<td align=\"left\">inSql(“id”, “select id from table where id &lt; 3”)</td>\n<td align=\"left\">id in (select id from table where id &lt; 3)</td>\n</tr>\n<tr>\n<td align=\"left\">notInSql</td>\n<td align=\"left\">字段 NOT IN (sql语句)</td>\n<td align=\"left\">notInSql(“id”, “select id from table where id &lt; 3”)</td>\n<td align=\"left\">age not in (select id from table where id &lt; 3)</td>\n</tr>\n<tr>\n<td align=\"left\">groupBy</td>\n<td align=\"left\">分组 GROUP BY 字段, …</td>\n<td align=\"left\">groupBy(“id”, “name”)</td>\n<td align=\"left\">group by id, name</td>\n</tr>\n<tr>\n<td align=\"left\">orderByAsc</td>\n<td align=\"left\">排序 ORDER BY 字段, … ASC</td>\n<td align=\"left\">orderByAsc(“id”, “name”)</td>\n<td align=\"left\">order by id ASC, name ASC</td>\n</tr>\n<tr>\n<td align=\"left\">orderByDesc</td>\n<td align=\"left\">排序 ORDER BY 字段, … DESC</td>\n<td align=\"left\">orderByDesc(“id”, “name”)</td>\n<td align=\"left\">order by id DESC, name DESC</td>\n</tr>\n<tr>\n<td align=\"left\">orderBy</td>\n<td align=\"left\">排序 ORDER BY 字段, …</td>\n<td align=\"left\">orderBy(true, true, “id”, “name”)</td>\n<td align=\"left\">order by id ASC, name ASC</td>\n</tr>\n<tr>\n<td align=\"left\">having</td>\n<td align=\"left\">HAVING (sql语句)</td>\n<td align=\"left\">having(“sum(age) &gt; {0}”, 11)</td>\n<td align=\"left\">having sum(age) &gt; 11</td>\n</tr>\n<tr>\n<td align=\"left\">or</td>\n<td align=\"left\">拼接 OR</td>\n<td align=\"left\">eq(“id”, 1).or().eq(“name”, “老王”)</td>\n<td align=\"left\">id &#x3D; 1 or name &#x3D; ‘老王</td>\n</tr>\n<tr>\n<td align=\"left\">and</td>\n<td align=\"left\">AND 嵌套</td>\n<td align=\"left\">and(i -&gt; i.eq(“name”, “李白”).ne(“status”, “活着”))</td>\n<td align=\"left\">and (name &#x3D; ‘李白’ and status &lt;&gt; ‘活着’)</td>\n</tr>\n<tr>\n<td align=\"left\">apply</td>\n<td align=\"left\">拼接sql</td>\n<td align=\"left\">apply(“date_format(dateColumn, ‘%Y-%m-%d’)&#x3D;{0}”, “2008-08-08”)</td>\n<td align=\"left\">date_format(dateColumn,’%Y-%m-%d’) &#x3D; ‘2008-08-08’)</td>\n</tr>\n<tr>\n<td align=\"left\">last</td>\n<td align=\"left\">无视优化规则直接拼接到sql的最后</td>\n<td align=\"left\">last(“limit 1”)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">exists</td>\n<td align=\"left\">拼接 EXISTS (sql语句)</td>\n<td align=\"left\">exists(“select id from table where age &#x3D; 1”)</td>\n<td align=\"left\">exists (select id from table where age &#x3D; 1)</td>\n</tr>\n<tr>\n<td align=\"left\">notExists</td>\n<td align=\"left\">拼接 NOT EXISTS (sql语句)</td>\n<td align=\"left\">notExists(“select id from table where age &#x3D; 1”)</td>\n<td align=\"left\">not exists (select id from table where age &#x3D; 1)</td>\n</tr>\n<tr>\n<td align=\"left\">nested</td>\n<td align=\"left\">正常嵌套不带AND或者0R</td>\n<td align=\"left\">nested(i -&gt; i.eq(“name”, “李白”). ne(“status”, “活着”))</td>\n<td align=\"left\">(name &#x3D; ‘李白’ and status &lt;&gt; ‘活着’)</td>\n</tr>\n</tbody></table>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><ul>\n<li><code>MyBatis-Plus</code>从数据库表到前端接口的业务流程是<code>数据库表-&gt;DTO-&gt;Mapper-&gt;Service-&gt;Controller</code>；</li>\n<li><code>DTO</code>是数据传输对象，表示数据库里的关系数据；</li>\n<li><code>Mapper</code>封装了基础的<code>CRUD</code>接口，提供了基础的数据库操作；</li>\n<li><code>Service</code>在<code>Mapper</code>的基础上提供条件构造器，便于我们编写复杂的数据库操作；</li>\n<li><code>Controller</code>将接口提供给前端调用，通常使用<code>Spring</code>提供的<code>RestController</code>。</li>\n</ul>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/papima/article/details/78219000\">ORM框架简介</a></li>\n<li><a href=\"https://blog.csdn.net/qlzw1990/article/details/116996422\">MyBatis-Plus LambdaQueryWrapper使用说明</a></li>\n<li><a href=\"https://adong.blog.csdn.net/article/details/122154137\">MyBatis plus 之 QueryWrapper、LambdaQueryWrapper、LambdaQueryChainWrapper</a></li>\n</ul>\n","categories":["学习笔记"],"tags":["Java","数据库"]},{"title":"如何使用Git管理hexo博客项目仓库","url":"/posts/8d70d0c84034.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在日常写博客的时候，我一般会在多台电脑上写作，然后在本地生成静态页面，部署到<code>GitHub Page</code>；此外，博客的源代码也需要在多台电脑之间同步，保证在部署页面时的一致性。因此，管理好博客的远程仓库是非常有必要的。今天就和大家分享一下，我平时是如何管理hexo博客项目仓库的。</p>\n<h1 id=\"管理分支\"><a href=\"#管理分支\" class=\"headerlink\" title=\"管理分支\"></a>管理分支</h1><p>hexo博客项目的使用环境为个人项目，因此无需过多关注多人协作情况下<code>Git</code>的注意事项。我们完全可以自己定义一套规矩，在写作时遵守即可。</p>\n<p><code>hexo deploy</code>命令会强行覆盖远程仓库的静态页面文件，因此有必要将页面文件与源代码分开存储。可以另外创建一个仓库，也可以新建一个分支，两个分支存储不同的文件。我使用的方案是新建一个分支。</p>\n<h2 id=\"使用不同分支\"><a href=\"#使用不同分支\" class=\"headerlink\" title=\"使用不同分支\"></a>使用不同分支</h2><p>在博客的根目录下找到<code>_config.yml</code>文件，修改<code>deploy</code>配置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">//</span> <span class=\"string\">填写你的仓库地址</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>这时，<code>hexo deploy</code>命令会将站点文件推送至默认的<code>master</code>分支。我们可以在<code>GitHub</code>中新建一个<code>hexo</code>分支，在本地也新建一个<code>hexo</code>分支，然后切换至<code>hexo</code>分支，将源代码<code>push</code>到远程的<code>origin/hexo</code>上，并将其设置为默认分支。这样的好处是每次执行<code>git clone</code>命令时无需关注克隆的是哪一个分支，因为默认克隆的是源代码而不是站点文件。之后，每次执行<code>hexo deploy</code>，都会创建一个提交信息为部署时间的commit，并刷新页面。</p>\n<p>于是，<code>hexo</code>分支的提交历史反映了我们对博客的页面做出的改动，<code>master</code>分支的提交历史反映了页面的更新历史。</p>\n<h2 id=\"合并修改\"><a href=\"#合并修改\" class=\"headerlink\" title=\"合并修改\"></a>合并修改</h2><p>当我在一台电脑上写作或修改源代码并推送至远程仓库后，如果要在另一台电脑上继续作业，正确的做法是先执行<code>git fetch</code>命令拉取远程仓库的代码，再执行<code>git pull</code>命令同步之前做的修改，保证一致性后再完成工作。如果我不小心忘记这一次同步呢？直接在本地继续工作，然后提交。如果修改的不是前一台电脑更改的文件，那倒不会产生什么影响，只需要补做前面同步的操作即可。如果恰好修改了前一台电脑更改的文件，那么显然会产生冲突。</p>\n<p>在多人协助的项目中，冲突也是时有发生，我们一般会采用执行<code>git merge</code>命令然后手动解决冲突的方式，这样会在分支上产生一个分叉，然后合并，同时产生一条<code>merge</code>信息提示这里曾进行过合并，<code>Git</code>会完整记录下我们对分支进行的每一次提交。</p>\n<p>然而，对于个人项目，我不希望我的分支产生多余的分叉，我想要让历史提交记录保持一条干净的直线，这时可以使用<code>git rebase</code>命令代替<code>git merge</code>，将本地的修改放到远程仓库上次修改的后面，使博客的更新历史既符合时间线又不产生分叉。</p>\n<h1 id=\"管理提交信息\"><a href=\"#管理提交信息\" class=\"headerlink\" title=\"管理提交信息\"></a>管理提交信息</h1><p>上面提到，分支上的每一次提交就是博客更新的时间线。除了保证分支的提交历史清晰可辨，提交的信息也要做到言简意赅。一般来说，提交信息要写明这次提交修改了哪些内容，并尽可能地简洁，这样在浏览分支的提交历史时，能清楚地明白每次提交做了什么事情。</p>\n<h2 id=\"使用amend\"><a href=\"#使用amend\" class=\"headerlink\" title=\"使用amend\"></a>使用amend</h2><p>当我在本地做了一些修改后进行了一次commit，之后又做了一些修改，想将这两次的修改合并到一个commit中，这时可以使用<code>--amend</code>参数，加到<code>git commit</code>后面，同时还能修改上一次提交时的提交信息。</p>\n<p>如果已经将上一次修改push到了远程仓库，我们也能使用<code>git commit --amend</code>命令，但执行<code>git push</code>命令时，需要加上<code>--force</code>参数强制推送到远程仓库</p>\n<p>使用<code>WebStorm</code>时，只需在commit界面勾选<code>amend</code>复选框即可。如果需要强制推送，在push时展开按钮选择<code>force push</code>即可。</p>\n<h2 id=\"使用rebase\"><a href=\"#使用rebase\" class=\"headerlink\" title=\"使用rebase\"></a>使用rebase</h2><p>如果需要修改前几次的提交信息，可以使用<code>git rebase -i</code>命令，具体使用方法如下：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git rebase <span class=\"literal\">-i</span> HEAD~<span class=\"number\">2</span> // <span class=\"number\">2</span> 表示最近两条commit</span><br><span class=\"line\">git rebase <span class=\"literal\">-i</span> &#123;commitID&#125; // 例如 git rebase <span class=\"literal\">-i</span> d95ddfb</span><br><span class=\"line\">git rebase <span class=\"literal\">-i</span> <span class=\"literal\">--root</span> // 表示从第一条commit开始编辑</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>指定<code>HEAD~</code>后面的数字表示编辑最近若干条commit<br>指定<code>commit ID</code>表示编辑这条commit之前的记录<br>指定–root参数表示从第一条commit开始编辑</p>\n</blockquote>\n<p>执行rebase命令后，会出现rebase的编辑窗口，窗口底下会有提示怎么操作。</p>\n<p>这里有几种修改选项：</p>\n<ul>\n<li><code>pick</code>：保留该commit</li>\n<li><code>reword</code>：保留该commit，但我需要修改该commit的Message</li>\n<li><code>edit</code>：保留该commit，但我要停下来修改该提交(包括修改文件)</li>\n<li><code>squash</code>：将该commit和前一个commit合并</li>\n<li><code>fixup</code>：将该commit和前一个commit合并，但我不要保留该提交的注释信息</li>\n<li><code>exec</code>：执行shell命令</li>\n<li><code>drop</code>：丢弃这个commit</li>\n</ul>\n<p>按字母<code>O</code>键进入编辑状态，开始修改内容。</p>\n<p>按<code>Esc</code>键退出编辑状态，可以输入各种命令，最常用的是输入<code>:q</code>直接退出，输入<code>:wq</code>进行保存并退出。</p>\n<p>修改完成后，执行<code>git push --force</code>命令推送至远程仓库即可。</p>\n<h2 id=\"UI交互式rebase\"><a href=\"#UI交互式rebase\" class=\"headerlink\" title=\"UI交互式rebase\"></a>UI交互式rebase</h2><p>上面使用命令行窗口编辑提交信息的操作非常繁琐，如果使用<code>WebStorm</code>来操作会非常简单。只需打开<code>Git</code>标签页，在中间的分支上选择你要编辑的起始commit，右键选择<code>Interactively Rebase From Here</code>，然后在弹出的窗口中编辑每一条要修改的commit即可。</p>\n<h2 id=\"重置代码\"><a href=\"#重置代码\" class=\"headerlink\" title=\"重置代码\"></a>重置代码</h2><p>如果遇到严重的问题，想要强制拉取并覆盖本地代码，可以使用<code>git reset</code>将本地分支重置到远程分支的最新提交。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git fetch <span class=\"literal\">--all</span></span><br><span class=\"line\">git reset <span class=\"literal\">--hard</span> origin/hexo</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用Gitmoji\"><a href=\"#使用Gitmoji\" class=\"headerlink\" title=\"使用Gitmoji\"></a>使用Gitmoji</h1><p>此外，我们还可以在每条提交信息前插入一些约定好的<code>emoji</code>表情，使得commit信息更加生动形象。因为是使用在<code>Git</code>里的，所以被称为<code>Gitmoji</code>。我节选了一些内容，更多用法可以参考它的<a href=\"https://gitmoji.dev/\">官网</a>。</p>\n<table>\n<thead>\n<tr>\n<th>emoji</th>\n<th>emoji代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>🎨</td>\n<td>:art:</td>\n<td>改进代码结构&#x2F;代码格式</td>\n</tr>\n<tr>\n<td>⚡️</td>\n<td>:zap:</td>\n<td>提升性能</td>\n</tr>\n<tr>\n<td>🔥</td>\n<td>:fire:</td>\n<td>移除代码或文件</td>\n</tr>\n<tr>\n<td>🐛</td>\n<td>:bug:</td>\n<td>修复bug</td>\n</tr>\n<tr>\n<td>⏪</td>\n<td>:rewind:</td>\n<td>回退修改</td>\n</tr>\n<tr>\n<td>📦</td>\n<td>:package:</td>\n<td>上传已经完成编译或者打包的项目</td>\n</tr>\n<tr>\n<td>👽</td>\n<td>:alien:</td>\n<td>API发生改变</td>\n</tr>\n<tr>\n<td>🚚</td>\n<td>:truck:</td>\n<td>移动或者重命名文件</td>\n</tr>\n<tr>\n<td>📄</td>\n<td>:page_facing_up:</td>\n<td>添加或者升级证书</td>\n</tr>\n<tr>\n<td>💥</td>\n<td>:boom:</td>\n<td>有结构性破坏的修改</td>\n</tr>\n<tr>\n<td>🍱</td>\n<td>:bento:</td>\n<td>添加资源</td>\n</tr>\n<tr>\n<td>🔍</td>\n<td>:mag:</td>\n<td>改进搜索方式</td>\n</tr>\n<tr>\n<td>🥅</td>\n<td>:goal_net:</td>\n<td>发现错误</td>\n</tr>\n<tr>\n<td>💫</td>\n<td>:dizzy:</td>\n<td>添加了动画</td>\n</tr>\n<tr>\n<td>🗑</td>\n<td>:wastebasket:</td>\n<td>过期代码需要被清理</td>\n</tr>\n<tr>\n<td>🚑</td>\n<td>:ambulance:</td>\n<td>关键补丁</td>\n</tr>\n<tr>\n<td>✨</td>\n<td>:sparkles:</td>\n<td>引入新的功能</td>\n</tr>\n<tr>\n<td>📝</td>\n<td>:memo:</td>\n<td>写README文档</td>\n</tr>\n<tr>\n<td>🚀</td>\n<td>:rocket:</td>\n<td>部署功能</td>\n</tr>\n<tr>\n<td>💄</td>\n<td>:lipstick:</td>\n<td>更新UI和样式文件</td>\n</tr>\n<tr>\n<td>🎉</td>\n<td>:tada:</td>\n<td>初次提交</td>\n</tr>\n<tr>\n<td>🔖</td>\n<td>:bookmark:</td>\n<td>发行&#x2F;版本标签</td>\n</tr>\n<tr>\n<td>⬆️</td>\n<td>:arrow_up:</td>\n<td>升级依赖</td>\n</tr>\n<tr>\n<td>⬇️</td>\n<td>:arrow_down:</td>\n<td>降级依赖</td>\n</tr>\n<tr>\n<td>➕</td>\n<td>:heavy_plus_sign:</td>\n<td>添加依赖</td>\n</tr>\n<tr>\n<td>➖</td>\n<td>:heavy_minus_sign:</td>\n<td>删除依赖</td>\n</tr>\n<tr>\n<td>🔨</td>\n<td>:hammer:</td>\n<td>重构</td>\n</tr>\n<tr>\n<td>🐳</td>\n<td>:whale:</td>\n<td>Docker 相关工作</td>\n</tr>\n<tr>\n<td>🔧</td>\n<td>:wrench:</td>\n<td>修改配置文件</td>\n</tr>\n<tr>\n<td>🌐</td>\n<td>:globe_with_meridians:</td>\n<td>国际化与本地化</td>\n</tr>\n<tr>\n<td>✏️</td>\n<td>:pencil2:</td>\n<td>修复typo</td>\n</tr>\n</tbody></table>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><ul>\n<li>博客项目使用两个分支分别存储源代码和站点文件，两个分支的提交历史分别反映了博客的页面改动与页面的更新历史；</li>\n<li>使用<code>Git</code>命令可以合并commit、修改commit信息。使用<code>WebStorm</code>操作更加方便；</li>\n<li>使用<code>Gitmoji</code>可以生动形象地描述commit内容。</li>\n</ul>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648\">Rebase - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_42310154/article/details/119004977\">git rebase详解</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/401811121\">Git 如何修改历史 Commit message</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_43314519/article/details/123317135\">Git修改commit信息方法大全</a></li>\n</ul>\n","categories":["经验分享"],"tags":["Git","博客"]},{"title":"如何在不同电脑上使用SSH访问同一个代码库","url":"/posts/acc0fec61eb5.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>最近在使用Git的过程中遇到了这样一个场景：我们有时需要在<strong>不同电脑</strong>上使用SSH访问<strong>同一个代码库</strong>，但每台电脑又有各自其他的用途。使用SSH访问代码托管平台时要生成密钥对，但又需要输入一个邮箱。</p>\n<p>大家有没有想过，我们在代码托管平台、Git本地库和生成SSH密钥对时都要输入一个邮箱用作用户名，这些邮箱有区别吗？生成SSH密钥对时输入什么邮箱比较合适？输入别的字符可以吗？如何让一台电脑能用<strong>不同用户名</strong>访问<strong>不同的代码库</strong>呢？下面，我们就来探讨一下这些问题。</p>\n<h1 id=\"SSH密钥\"><a href=\"#SSH密钥\" class=\"headerlink\" title=\"SSH密钥\"></a>SSH密钥</h1><p>大多数Git教程都会告诉你，生成SSH密钥时在<code>-C</code>后输入你在Git中设置<code>user.email</code>那里填写的邮箱就可以了，而且在很多教程里都会看到这行命令：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh<span class=\"literal\">-keygen</span> <span class=\"literal\">-t</span> rsa <span class=\"literal\">-C</span> <span class=\"string\">&quot;username@email.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>你看，命令都是这么写的，让你输入一个邮箱，是吧。</p>\n<p>事实上，ssh-keygen命令中常用的参数是这样解释的：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">-t</td>\n<td align=\"left\">指定要创建的密钥类型，一般采用rsa加密方式，另外有dsa</td>\n</tr>\n<tr>\n<td align=\"left\">-b</td>\n<td align=\"left\">指定密钥长度，rsa默认2048bit</td>\n</tr>\n<tr>\n<td align=\"left\">-f</td>\n<td align=\"left\">指定用来保存密钥的文件名，可以不指定</td>\n</tr>\n<tr>\n<td align=\"left\">-C</td>\n<td align=\"left\">添加备注</td>\n</tr>\n</tbody></table>\n<p>我们尝试输入这行命令：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh<span class=\"literal\">-keygen</span> <span class=\"literal\">-t</span> rsa <span class=\"literal\">-C</span> <span class=\"string\">&quot;username@email.com&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上命令省略了-f参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的SSH key代码，你一般会看到如下的文字：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> which to save the key (/Users/yourusername/.ssh/id_rsa): [<span class=\"type\">Press</span> <span class=\"type\">enter</span>]</span><br></pre></td></tr></table></figure>\n\n<p>不输入文件名，按下回车后，会在你电脑的User文件夹的<code>.ssh</code>路径下创建一个加密方式为<code>rsa</code>、注释为<code>username@email.com</code>的SSH密钥，而且会同时生成一对公钥和私钥，文件名为<code>id_rsa</code>，公钥的文件后缀名为<code>.pub</code>，私钥没有后缀名。</p>\n<p>因此，在生成SSH密钥时，输入邮箱只是起到一个<strong>备注</strong>的作用，填写其他<strong>任意内容</strong>均可，也跟你的Git用户名<strong>没有任何关系</strong>。一台电脑使用<strong>一个</strong>SSH密钥就能访问<strong>多个</strong>远程服务器。</p>\n<h1 id=\"合理使用注释\"><a href=\"#合理使用注释\" class=\"headerlink\" title=\"合理使用注释\"></a>合理使用注释</h1><p>那么，我们该如何填写注释，在日常使用中更方便地区分它们呢？</p>\n<p>我列举这样一个场景：我在公司使用台式机办公，同时家里有一台台式机，自己有一台笔记本电脑。我有一些个人的兴趣性项目，代码托管在GitHub上，同时有一些公司的项目，代码托管在公司服务器上。我会在公司电脑上使用SSH访问公司服务器的代码库，并且偶尔需要用公司电脑访问自己的个人代码；在家里会使用台式机和笔记本访问自己的GitHub。</p>\n<p>用表格列举如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">电脑名称</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">HomePC</td>\n<td align=\"left\">家中使用的台式电脑</td>\n</tr>\n<tr>\n<td align=\"left\">CompanyPC</td>\n<td align=\"left\">公司使用的台式电脑</td>\n</tr>\n<tr>\n<td align=\"left\">Laptop</td>\n<td align=\"left\">自己的笔记本电脑</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">代码托管平台</th>\n<th align=\"left\">用户名</th>\n<th align=\"left\">email</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GitHub</td>\n<td align=\"left\">personal</td>\n<td align=\"left\"><a href=\"mailto:&#112;&#x65;&#114;&#x73;&#111;&#110;&#97;&#x6c;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;\">&#112;&#x65;&#114;&#x73;&#111;&#110;&#97;&#x6c;&#64;&#113;&#x71;&#46;&#99;&#111;&#109;</a></td>\n<td align=\"left\">个人邮箱</td>\n</tr>\n<tr>\n<td align=\"left\">公司服务器</td>\n<td align=\"left\">company</td>\n<td align=\"left\"><a href=\"mailto:&#99;&#x6f;&#x6d;&#112;&#x61;&#110;&#121;&#x40;&#99;&#x6f;&#109;&#112;&#x61;&#110;&#x79;&#x2e;&#99;&#x6e;\">&#99;&#x6f;&#x6d;&#112;&#x61;&#110;&#121;&#x40;&#99;&#x6f;&#109;&#112;&#x61;&#110;&#x79;&#x2e;&#99;&#x6e;</a></td>\n<td align=\"left\">公司邮箱</td>\n</tr>\n</tbody></table>\n<p>从某种角度上看，我们的代码库和开发环境存在<strong>多对多</strong>的关联关系，三乘以二等于六，是不是我们也要创建6个SSH密钥对呢？不是的。</p>\n<p>我们需要留意到，在设置Git用户名和密码时，我们总是添加<code>-global</code>参数，让计算机上所有的Git库都使用同一个用户名。因此，我们完全可以在某些本地库中设置<strong>单独</strong>的用户名和密码，来访问特定的远程库。</p>\n<p>以上面的情况为例，我们可以给每台电脑只创建一个SSH密钥对，在公司台式机上针对个人代码的<strong>本地库</strong>设置Git用户名为<code>personal@qq.com</code>，<strong>全局</strong>用户名设置为<code>company@company.cn</code>，然后在家里的台式机和笔记本上设置<strong>全局</strong>用户名为<code>personal@qq.com</code>。</p>\n<p>最后，在设置好Git用户名之后，给各台电脑的密钥对添加注释，填写<strong>每台电脑的名称</strong>，而不是邮箱。用表格列举如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">电脑名称</th>\n<th align=\"left\">密钥对注释</th>\n<th align=\"left\">代码托管网站上显示密钥标题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">HomePC</td>\n<td align=\"left\">-C “HomePC”</td>\n<td align=\"left\">HomePC</td>\n</tr>\n<tr>\n<td align=\"left\">CompanyPC</td>\n<td align=\"left\">-C “CompanyPC”</td>\n<td align=\"left\">CompanyPC</td>\n</tr>\n<tr>\n<td align=\"left\">Laptop</td>\n<td align=\"left\">-C “Laptop”</td>\n<td align=\"left\">Laptop</td>\n</tr>\n</tbody></table>\n<p>理清关系后，我们发现，SSH密钥对其实是与<strong>每台电脑</strong>关联的，而非Git用户。把密钥添加到代码托管网站上的时候，最好用一个跟这台电脑密切相关的注释。以后如果不使用这台电脑了，从网站上删除这个密钥很方便。</p>\n<blockquote>\n<p>这里需要注意的是代码托管网站对本地设定的Git用户是如何处理的。代码托管网站主要关注Git用户名<code>user.email</code>，用<code>user.email</code>来匹配托管平台账户名的<strong>邮件地址</strong>，如果相同，代码托管网站就认为此操作是账户所有者的操作。下面举一个例子：<br>如果本地设定的<code>user.email</code>是<code>personal@qq.com</code>，由于在GitHub账户的邮件地址也是<code>personal@qq.com</code>，如果从这台电脑push的话，GitHub会认定这次push是账户拥有者自己做的；如果本地设定的<code>user.email</code>是<code>company@company.cn</code>，也能push到GitHub，但GitHub会记录这次的修改是另一个用户名为<code>company</code>的人做的。</p>\n</blockquote>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><ul>\n<li><p>使用ssh-keygen命令产生密钥对，每台电脑有<strong>一对</strong>就够了。</p>\n</li>\n<li><p>在本地生成ssh密钥对时，推荐用<strong>计算机相关信息</strong>而不是用户名作为密钥对的注释。在代码托管网站上，也推荐用这个信息来做密钥对的标题。</p>\n</li>\n<li><p>配置本地Git用户名时，全局配置（<code>–global</code>）要考虑该电脑上的工作主要push到哪个远程服务器，然后配置成跟那个服务器一致的用户名和邮件地址。</p>\n</li>\n<li><p>除了主要push的服务器外，如果这台电脑上的工作还需要push到其他服务器，那么在具体的本地库目录下，把用户名和邮件地址配置成与特定服务器相同即可。</p>\n</li>\n</ul>\n<p>经过上面的操作，我们可以愉快地在不同的电脑上用相同的账户访问同一个代码库，同时不影响电脑其他的工作，并且能够更加清晰地分辨每个SSH密钥的用途。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">Git教程 - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/qq_40932679/article/details/117487540\">ssh-keygen命令详解</a></li>\n<li><a href=\"https://blog.csdn.net/belongtocode/article/details/100716812\">对Git用户名与Github账户关系的理解</a></li>\n</ul>\n","categories":["经验分享"],"tags":["Git","服务器"]},{"title":"如何禁用或移除Windows Defender？","url":"/posts/3033685adfef.html","content":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>这篇文章用于汇总从搜索引擎上收集的禁用Windows Defender的零散方法。由于Windows Defender杀毒效果一般，其实时保护功能有时会占用非常多的系统资源，我在每次重装系统后第一时间都会将其禁用和卸载。</p>\n<blockquote>\n<p>注意：本文记录的内容仅适用于Windows 10</p>\n</blockquote>\n<blockquote>\n<p>在此声明，禁用杀毒软件会导致你的系统安全处于危险之中，不建议普通用户这么操作！</p>\n</blockquote>\n<h1 id=\"使用组策略禁用Windows-Defender\"><a href=\"#使用组策略禁用Windows-Defender\" class=\"headerlink\" title=\"使用组策略禁用Windows Defender\"></a>使用组策略禁用Windows Defender</h1><p>该方法的好处是可恢复，当你需要再次使用，你可以重新恢复Windows Defender。</p>\n<blockquote>\n<p>注意：如果你的Windows 10是家庭版，请下载<a href=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/file/post/remove-windows-defender/WindowsDefenderRemoveScript.zip\">启用Windows 10 Home组策略脚本</a>来安装组策略。下载解压后是一个Windows批处理文件<code>gpedit-enabler.bat</code>，请右键单击该文件，选择<strong>以管理员权限运行</strong>。</p>\n</blockquote>\n<ol>\n<li>按<code>WIN+R</code>调出运行，然后输入<code>gpedit.msc</code>，点击确定</li>\n<li>然后在策略组中依此展开<strong>计算机管理-管理模板-Windows组件-Windows Defender</strong></li>\n<li>然后找到<strong>关闭Windows Defender</strong>，双击后设置为<strong>已启用</strong>，然后应用并确定即可</li>\n</ol>\n<h1 id=\"使用批处理脚本完全卸载Windows-Defender\"><a href=\"#使用批处理脚本完全卸载Windows-Defender\" class=\"headerlink\" title=\"使用批处理脚本完全卸载Windows Defender\"></a>使用批处理脚本完全卸载Windows Defender</h1><p>如果你想完全卸载Windows Defender，不留任何相关服务，避免和其他软件冲突，你可以使用以下方法。但是注意，此方法不可逆，如果使用了，Windows Defender就不能再恢复。</p>\n<ol>\n<li>下载移除Windows Defender的<a href=\"https://gcore.jsdelivr.net/gh/Xe-Persistent/CDN-source/file/post/remove-windows-defender/gpedit-enabler.zip\">专用脚本</a></li>\n<li>下载后解压，右键单击<code>Uninstall.cmd</code>后，选择<strong>以管理员权限运行</strong></li>\n</ol>\n<p>脚本内容：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">cd</span> /d &quot;%~dp0&quot;</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Uninstalling ...</span><br><span class=\"line\"><span class=\"built_in\">CLS</span></span><br><span class=\"line\">install_wim_tweak.exe /o /l</span><br><span class=\"line\">install_wim_tweak.exe /o /c &quot;Windows-Defender&quot; /r</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">install_wim_tweak.exe /h /o /l</span><br><span class=\"line\"><span class=\"built_in\">echo</span> It should be uninstalled. Please reboot Windows <span class=\"number\">10</span>.</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n<p>该脚本是是利用<code>install_wim_tweak.exe</code>调用系统API来卸载Windows Defender这个Windows核心组件。该脚本必须以管理员权限才能正常运行。</p>\n<ol start=\"3\">\n<li>执行完成后，重启计算机，就可以看到Windows Defender已经完全消失了。与此同时，组策略中与Windows Defender有关的内容也消失了</li>\n</ol>\n<h1 id=\"关闭Windows安全中心\"><a href=\"#关闭Windows安全中心\" class=\"headerlink\" title=\"关闭Windows安全中心\"></a>关闭Windows安全中心</h1><p>禁用或卸载后，如果不想在状态栏看到Windows安全中心，可以参照下面的方法将其关闭。</p>\n<ol>\n<li>按<code>WIN+R</code>调出运行，然后输入<code>regedit</code>，点击确定</li>\n<li>定位到<code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SecurityHealthService</code></li>\n<li>在右侧找到<code>start</code>一项，双击将数值数据一栏改为<strong>4</strong>即可</li>\n</ol>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://www.reneelab.com.cn/forbidden-windows-defender.html\">如何禁用或者完全移除Windows Defender？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30675056\">如何关闭Windows Defender</a></li>\n</ul>\n","categories":["经验分享"],"tags":["杂记"]},{"title":"如何重构if-else写出优雅高效代码","url":"/posts/14d0abf73d03.html","content":"<h1 id=\"为什么我们写的代码都是if-else？\"><a href=\"#为什么我们写的代码都是if-else？\" class=\"headerlink\" title=\"为什么我们写的代码都是if-else？\"></a>为什么我们写的代码都是if-else？</h1><p>程序员想必都经历过这样的场景：刚开始自己写的代码很简洁，逻辑清晰，函数精简，没有一个<code>if-else</code>。可随着代码逻辑不断完善和业务的瞬息万变，比如需要对入参进行类型和值进行判断；这里要判断下字段是否为<code>null</code>；不同类型执行不同的流程，落地到具体实现只能不停地加<code>if-else</code>来处理。渐渐地，代码变得越来越庞大，函数越来越长，代码行数也迅速突破上千行，维护难度也越来越大，到后期基本达到一种难以维护的状态。</p>\n<p><strong>虽然我们都很不情愿写出满屏<code>if-else</code>的代码，可逻辑上就是需要特殊判断，很绝望，可也没办法避免啊。</strong></p>\n<p>其实回头看看自己的代码，写<code>if-else</code>无外乎两种场景：<strong>异常逻辑处理和不同状态处理。</strong></p>\n<p>两者最主要的区别是：<strong>异常逻辑处理说明只能一个分支是正常流程，而不同状态处理都所有分支都是正常流程。</strong></p>\n<h2 id=\"代码if-else代码太多有什么缺点？\"><a href=\"#代码if-else代码太多有什么缺点？\" class=\"headerlink\" title=\"代码if-else代码太多有什么缺点？\"></a>代码if-else代码太多有什么缺点？</h2><p>缺点相当明显了：</p>\n<ol>\n<li>最大的问题是代码逻辑复杂，维护性差，极容易引发bug。</li>\n<li>如果使用<code>if-else</code>，说明<code>if</code>分支和<code>else</code>分支的重视是同等的，但大多数情况并非如此，容易引起误解和理解困难。</li>\n</ol>\n<h2 id=\"是否有好的方法优化？如何重构？\"><a href=\"#是否有好的方法优化？如何重构？\" class=\"headerlink\" title=\"是否有好的方法优化？如何重构？\"></a>是否有好的方法优化？如何重构？</h2><p>方法肯定是有的。重构<code>if-else</code>时，心中每时每刻把握一个原则：</p>\n<p><strong>尽可能地维持正常流程代码在最外层。</strong></p>\n<p>意思是说，可以写<code>if-else</code>语句时一定要尽量保持主干代码是正常流程，避免嵌套过深。</p>\n<p>怎么理解？举两个例子：</p>\n<blockquote>\n<p>举例一：异常逻辑处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> getObj();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>举例二：状态处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> getObj();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj.getType == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj.getType == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一个例子<code>if (obj != null)</code>是异常处理，是代码健壮性判断，只有<code>if</code>里面才是正常的处理流程，<code>else</code>分支是出错处理流程；</p>\n<p>而第二个例子不管<code>type</code>等于1、2还是其他情况，都属于业务的正常流程。</p>\n<p>对于这两种情况，重构的方法也不一样。实现的手段有：<em>减少嵌套</em>、<em>移除临时变量</em>、<em>条件取反判断</em>、<em>合并条件表达式</em>等。</p>\n<p>下面针对不同情形举几个实例来讲解这些重构方法。</p>\n<h1 id=\"异常逻辑处理型重构\"><a href=\"#异常逻辑处理型重构\" class=\"headerlink\" title=\"异常逻辑处理型重构\"></a>异常逻辑处理型重构</h1><h2 id=\"实例一：合并条件表达式\"><a href=\"#实例一：合并条件表达式\" class=\"headerlink\" title=\"实例一：合并条件表达式\"></a>实例一：合并条件表达式</h2><p>重构前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">disablityAmount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_seniority &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_monthsDisabled &gt; <span class=\"number\">12</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isPartTime) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重构后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">disablityAmount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_seniority &lt; <span class=\"number\">2</span> || _monthsDisabled &gt; <span class=\"number\">12</span> || _isPartTime)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的重构手法叫<strong>合并条件表达式</strong>：如果有一系列条件测试都得到相同结果，将这些结果测试合并为一个条件表达式。</p>\n<p>这个重构手法简单易懂，带来的效果也非常明显，能有效地较少<code>if</code>语句，减少代码量逻辑上也更加易懂。</p>\n<h2 id=\"实例二：移除临时变量\"><a href=\"#实例二：移除临时变量\" class=\"headerlink\" title=\"实例二：移除临时变量\"></a>实例二：移除临时变量</h2><p>重构前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">getPayAmount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isDead) &#123;</span><br><span class=\"line\">        result = deadAmount();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_isSeparated) &#123;</span><br><span class=\"line\">            result = separatedAmount();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_isRetired) &#123;</span><br><span class=\"line\">                result = retiredAmount();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result = normalPayAmount();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重构后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">getPayAmount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isDead) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> deadAmount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isSeparated) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> separatedAmount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isRetired) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> retiredAmount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> normalPayAmount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么样？比对两个版本，会发现重构后的版本逻辑清晰，简洁易懂。</p>\n<p>和重构前到底有什么区别呢？</p>\n<p>最大的区别是<strong>减少<code>if-else</code>嵌套</strong>。</p>\n<p>可以看到，最初的版本<code>if-else</code>最深的嵌套有三层，看上去逻辑分支非常多，进到里面基本都要被绕晕。其实，仔细想想嵌套内的<code>if-else</code>和最外层并没有关联性，完全可以提取最顶层，改为平行关系，而非包含关系。<code>if-else</code>数量没有变化，但是逻辑清晰明了，一目了然。</p>\n<p>另一个重构点是<strong>废除了<code>result</code>临时变量，直接<code>return</code>返回</strong>。好处也显而易见：直接结束流程，缩短异常分支流程。原来的做法先赋值给<code>result</code>最后统一<code>return</code>，那么对于最后<code>return</code>的值到底是哪个函数返回的结果不明确，增加了一层理解难度。</p>\n<p>总结重构的要点：<strong>如果<code>if-else</code>嵌套没有关联性，直接提取到第一层，一定要避免逻辑嵌套太深。尽量减少临时变量改用<code>return</code>直接返回。</strong></p>\n<h2 id=\"实例三：条件取反判断\"><a href=\"#实例三：条件取反判断\" class=\"headerlink\" title=\"实例三：条件取反判断\"></a>实例三：条件取反判断</h2><p>重构前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getAdjustedCapital</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_capital &gt; <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_intRate &gt; <span class=\"number\">0</span> &amp;&amp; _duration &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            result = (_income / _duration) * ADJ_FACTOR;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一步，运用第一招：减少嵌套和移除临时变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getAdjustedCapital</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_capital &lt;= <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_intRate &gt; <span class=\"number\">0</span> &amp;&amp; _duration &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (_income / _duration) * ADJ_FACTOR;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样重构后，还不够，因为主要的语句<code>(_income / _duration) * ADJ_FACTOR</code>在<code>if</code>内部，并非在最外层，根据优化原则「<em>尽可能地维持正常流程代码在最外层</em>」，可以再继续重构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getAdjustedCapital</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_capital &lt;= <span class=\"number\">0.0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_intRate &lt;= <span class=\"number\">0</span> || _duration &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0.0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (_income / _duration) * ADJ_FACTOR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这才是好的代码风格，逻辑清晰，一目了然，没有<code>if-else</code>嵌套难以理解的流程。</p>\n<p>这里用到的重构方法是：<strong>将条件反转使异常情况先退出，让正常流程维持在主干流程</strong>。</p>\n<h2 id=\"实例四：减少if-else嵌套\"><a href=\"#实例四：减少if-else嵌套\" class=\"headerlink\" title=\"实例四：减少if-else嵌套\"></a>实例四：减少if-else嵌套</h2><p>重构前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找年龄大于18岁且为男性的学生列表 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList&lt;Student&gt; <span class=\"title function_\">getStudents</span><span class=\"params\">(<span class=\"type\">int</span> uid)</span> &#123;</span><br><span class=\"line\">    ArrayList&lt;Student&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Student&gt;();</span><br><span class=\"line\">    <span class=\"type\">Student</span> <span class=\"variable\">stu</span> <span class=\"operator\">=</span> getStudentByUid(uid);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stu != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">Teacher</span> <span class=\"variable\">teacher</span> <span class=\"operator\">=</span> stu.getTeacher();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (teacher != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ArrayList&lt;Student&gt; students = teacher.getStudents();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (students != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Student student : students) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (student.getAge() &gt; = <span class=\"number\">18</span> &amp;&amp; student.getGender() == MALE) &#123;</span><br><span class=\"line\">                        result.add(student);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">&quot;获取学生列表失败&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;获取老师信息失败&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">&quot;获取学生信息失败&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>典型的「箭头型」代码，最大的问题是<strong>嵌套过深</strong>，解决方法是异常条件先退出，保持主干流程是核心流程。</p>\n<p>重构后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找年龄大于18岁且为男性的学生列表</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ArrayList&lt;Student&gt; <span class=\"title function_\">getStudents</span><span class=\"params\">(<span class=\"type\">int</span> uid)</span> &#123;</span><br><span class=\"line\">    ArrayList&lt;Student&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Student&gt;();</span><br><span class=\"line\">    <span class=\"type\">Student</span> <span class=\"variable\">stu</span> <span class=\"operator\">=</span> getStudentByUid(uid);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stu == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">&quot;获取学生信息失败&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">Teacher</span> <span class=\"variable\">teacher</span> <span class=\"operator\">=</span> stu.getTeacher();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (teacher == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">&quot;获取老师信息失败&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ArrayList&lt;Student&gt; students = teacher.getStudents();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (students == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">&quot;获取学生列表失败&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student student : students) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (student.getAge() &gt; <span class=\"number\">18</span> &amp;&amp; student.getGender() == MALE) &#123;</span><br><span class=\"line\">            result.add(student);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"状态处理型重构\"><a href=\"#状态处理型重构\" class=\"headerlink\" title=\"状态处理型重构\"></a>状态处理型重构</h1><h2 id=\"实例一：封装成内部函数\"><a href=\"#实例一：封装成内部函数\" class=\"headerlink\" title=\"实例一：封装成内部函数\"></a>实例一：封装成内部函数</h2><p>重构前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">getPayAmount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> getObj();</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">money</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.getType == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">ObjectA</span> <span class=\"variable\">objA</span> <span class=\"operator\">=</span> obj.getObjectA();</span><br><span class=\"line\">        money = objA.getMoney() * obj.getNormalMoneryA();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj.getType == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">ObjectB</span> <span class=\"variable\">objB</span> <span class=\"operator\">=</span> obj.getObjectB();</span><br><span class=\"line\">        money = objB.getMoney() * obj.getNormalMoneryB() + <span class=\"number\">1000</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重构后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">getPayAmount</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> getObj();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.getType == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getType1Money(obj);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (obj.getType == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getType2Money(obj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">getType1Money</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ObjectA</span> <span class=\"variable\">objA</span> <span class=\"operator\">=</span> obj.getObjectA();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objA.getMoney() * obj.getNormalMoneryA();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">getType2Money</span><span class=\"params\">(Object obj)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ObjectB</span> <span class=\"variable\">objB</span> <span class=\"operator\">=</span> obj.getObjectB();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objB.getMoney() * obj.getNormalMoneryB() + <span class=\"number\">1000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里使用的重构方法是：<strong>把<code>if-else</code>内的代码都封装成一个内部函数</strong>。内部函数的好处是屏蔽内部实现，缩短<code>if-else</code>分支的代码。代码结构和逻辑上清晰，能一下看出来每一个条件下实现的功能。</p>\n<h2 id=\"实例二：用多态取代条件表达式\"><a href=\"#实例二：用多态取代条件表达式\" class=\"headerlink\" title=\"实例二：用多态取代条件表达式\"></a>实例二：用多态取代条件表达式</h2><p>针对状态处理的代码，一种优雅的做法是「<em>《重构》推荐做法</em>」<strong>用多态取代条件表达式</strong>。</p>\n<blockquote>\n<p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。将这个表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。</p>\n</blockquote>\n<p>重构前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> <span class=\"title function_\">getSpeed</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (_type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EUROPEAN:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getBaseSpeed();</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AFRICAN:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getBaseSpeed() - getLoadFactor() * _numberOfCoconuts;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> NORWEGIAN_BLUE:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (_isNailed) ? <span class=\"number\">0</span> : getBaseSpeed(_voltage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重构后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"type\">double</span> <span class=\"title function_\">getSpeed</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">European</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"title function_\">getSpeed</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBaseSpeed();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">African</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"title function_\">getSpeed</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBaseSpeed() - getLoadFactor() * _numberOfCoconuts;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NorwegianBlue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"title function_\">getSpeed</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (_isNailed) ? <span class=\"number\">0</span> : getBaseSpeed(_voltage);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，使用多态后直接没有了<code>if-else</code>，但使用多态对原本代码修改过大，需要下一番功夫才行。最好在设计之初就使用多态方式。</p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p><code>if-else</code>代码是每一个程序员最容易写出的代码，同时也是最容易被写烂的代码，稍不注意，就产生一堆难以维护和逻辑混乱的代码。</p>\n<p>针对条件型代码重构时刻把握一个原则：</p>\n<p><strong>尽可能地维持正常流程代码在最外层，保持主干流程是正常核心流程。</strong></p>\n<p>为维持这个原则，合并条件表达式可以有效地减少<code>if</code>语句数目，减少嵌套能减少深层次逻辑，异常条件先退出自然而然主干流程就是正常流程。</p>\n<p>针对状态处理型重构方法有两种：一种是把不同状态的操作封装成内部函数，简短<code>if-else</code>内代码行数；另一种是利用面向对象多态特性直接干掉了条件判断。</p>\n<p>现在回头看看自己的代码，犯了哪些典型错误，赶紧运用这些重构方法重构代码吧！</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>本文转自CSDN博主「yinnnnnnn」的文章<a href=\"https://blog.csdn.net/qq_35440678/article/details/77939999\">6个实例详解如何把if-else代码重构成高质量代码</a></p>\n","categories":["经验分享"],"tags":["Java","开发"]},{"title":"实战PostgreSQL分区表","url":"/posts/a68cfe88e8ff.html","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>随着项目使用年限的增长，数据库的数据量与日俱增，数据库查询也变得越来越慢。对于许多应用数据库来说，随着时间推移，一部分数据会作为历史数据来使用，并且它们的重要性逐渐降低。如果能够在查询时只查最近产生的数据，数据库查询速度将会大幅提高。此外，当一个数据表大小达到一定程度时，索引的性能也会降低，就如同一本书，当它的字数足够多，厚度也变得相当厚时，即使通过目录来查找阅读相应的文字也相当费劲。这种情况下，我们可以引入分区表，也就是将数据表划分，进而分而治之。</p>\n<h1 id=\"术语介绍\"><a href=\"#术语介绍\" class=\"headerlink\" title=\"术语介绍\"></a>术语介绍</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>表的划分指的是将逻辑上的一个大表分成一些小的物理上的分表，将数据分散到不同的子表中，并通过父表建立关联关系，从而实现数据表的分区。</p>\n<ul>\n<li><dl><dt>主表&#x2F;父表&#x2F;Master Table</dt><dd>该表是创建子表的模板。从数据的查询操作上看，它与普通表没有什么区别，但实际上所有数据都将储存在子表中，主表仅仅只是一个模板。</dd></dl></li>\n<li><dl><dt>子表&#x2F;分区表&#x2F;Child Table&#x2F;Partition Table</dt><dd>子表继承并从属于一个主表，子表中存储所有的数据。主表与分区表属于一对多的关系，也就是说，一个主表包含多个分区表，而一个分区表只从属于一个主表。</dd></dl></li>\n</ul>\n<h2 id=\"声明式划分\"><a href=\"#声明式划分\" class=\"headerlink\" title=\"声明式划分\"></a>声明式划分</h2><p>PostgreSQL提供了<code>PARTITION BY</code>子句指定如何把一个表划分成称为分区的片段，被划分的表被称作分区表。<code>PARTITION BY</code>子句由分区方法以及用作分区键的列或者表达式列表组成。</p>\n<p>所有被插入到分区表的行将被基于分区键的值路由到分区中。每个分区都有一个由其分区边界定义的数据子集。目前PgSQL支持的分区方法有范围划分、列表划分以及哈希划分。</p>\n<p>分区本身也可能被定义为分区表，这种用法被称为子分区。分区可以有自己的与其他分区不同的索引、约束以及默认值。</p>\n<p>无法把一个常规表转换成分区表，反之亦然。不过，可以把一个包含数据的常规表或者分区表作为分区加入到另一个分区表，或者从分区表中移走一个分区把它变成一个独立的表。</p>\n<p>PostgreSQL支持以下3种声明式分区形式：</p>\n<ul>\n<li><dl><dt>范围划分</dt><dd>通过一个或一组分区键来划分表，每个分区键设定一个区间范围，不同的分区的范围之间没有重叠。例如，我们可以根据日期范围划分，或者根据特定业务对象的标识符划分。</dd></dl></li>\n<li><dl><dt>列表划分</dt><dd>通过显式地列出每一个分区中出现的键值来划分表。</dd></dl></li>\n<li><dl><dt>哈希划分</dt><dd>通过为每个分区指定模数和余数来划分表。每个分区所持有的行都满足相同条件：该行分区键的值除以一个指定的模数将产生一个指定的余数。</dd></dl></li>\n</ul>\n<blockquote>\n<p>事实上，分区表还可以使用表继承来实现，具体方式详见<a href=\"http://www.postgres.cn/docs/12/ddl-partitioning.html#DDL-PARTITIONING-IMPLEMENTATION-INHERITANCE\">PostgreSQL文档</a>，本文不作讨论。</p>\n</blockquote>\n<h2 id=\"分区表的特性\"><a href=\"#分区表的特性\" class=\"headerlink\" title=\"分区表的特性\"></a>分区表的特性</h2><ul>\n<li><p>分区表的<code>CHECK</code>约束和<code>NOT NULL</code>约束总是会被其所有的分区所继承。不允许在分区表上创建标记为<code>NO INHERIT</code>的<code>CHECK</code>约束。</p>\n</li>\n<li><p>只要分区表中不存在分区，则支持使用<code>ONLY</code>仅在分区表上增加或者删除约束。当分区存在时是不支持仅在分区表上增加或删除约束的，分区表自身的约束可以增加（如果它们不出现在父表中）和删除。</p>\n</li>\n<li><p>分区表并不直接拥有任何数据，因此无法在分区表上使用<code>TRUNCATE ONLY</code>。</p>\n</li>\n<li><p>分区表不能有在父表中不存在的列，反之同理。在使用<code>CREATE TABLE</code>创建分区时不能指定列，在事后使用<code>ALTER TABLE</code>时也不能为分区增加列。只有当表的列正好匹配父表时，才能使用<code>ALTER TABLE ... ATTACH PARTITION</code>将它作为分区加入。</p>\n</li>\n<li><p>如果<code>NOT NULL</code>约束在父表中存在，那么不能删除分区表的列上对应的<code>NOT NULL</code>约束。</p>\n</li>\n</ul>\n<h2 id=\"分区表的优势\"><a href=\"#分区表的优势\" class=\"headerlink\" title=\"分区表的优势\"></a>分区表的优势</h2><ul>\n<li><p>在某些情况下查询性能能够显著提升，特别是当一些经常访问的数据行分布在一个分区或者少数几个分区时，划分可以取代索引的主导列、减小索引尺寸以及使索引中访问压力大的部分更有可能被放在缓存中。</p>\n</li>\n<li><p>当查询或更新一个分区的大部分数据行时，可以通过该分区上的一个顺序扫描来取代分散到整个表上的索引和随机访问，这样可以改善性能。</p>\n</li>\n<li><p>如果批量操作的需求是在分区设计时就规划好的，则批量装载和删除可以通过增加或者去除分区来完成。执行<code>ALTER TABLE DETACH PARTITION</code>或者使用<code>DROP TABLE</code>删除一个分区远比批量操作数据要快。</p>\n</li>\n<li><p>很少使用的数据分区可以被迁移到便宜且较慢的存储介质上。</p>\n</li>\n</ul>\n<p>一个表在何种情况下能够从划分获益取决于实际应用，一个经验法则是当表的尺寸超过了数据库服务器物理内存时，划分会为表带来好处。</p>\n<h2 id=\"分区表的限制\"><a href=\"#分区表的限制\" class=\"headerlink\" title=\"分区表的限制\"></a>分区表的限制</h2><ul>\n<li><p>没有办法创建跨越所有分区的约束，只能单个约束每个子表。</p>\n</li>\n<li><p>分区表上的唯一约束必须包括所有分区键列，存在此限制是因为PostgreSQL只能每个子表中分别实施唯一性。</p>\n</li>\n<li><p>只需要在子表上定义<code>BEFORE ROW</code>触发器，父表上不需要。</p>\n</li>\n<li><p>不允许在同一个分区树中混杂临时关系和持久关系。因此，如果分区表是持久的，则其分区也必须是持久的，反之亦然。在使用临时关系时，分区树的所有成员都必须来自于同一个会话。</p>\n</li>\n</ul>\n<h2 id=\"创建分区表\"><a href=\"#创建分区表\" class=\"headerlink\" title=\"创建分区表\"></a>创建分区表</h2><p>假定我们正在为一个大型的冰激凌公司构建数据库。该公司需要了解每天的最高气温以及每天每个区域的冰激凌销售情况。通常，我们会设计这样的表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement (</span><br><span class=\"line\">    city_id         <span class=\"type\">int</span> <span class=\"keyword\">not null</span>,</span><br><span class=\"line\">    logdate         <span class=\"type\">date</span> <span class=\"keyword\">not null</span>,</span><br><span class=\"line\">    peaktemp        <span class=\"type\">int</span>,</span><br><span class=\"line\">    unitsales       <span class=\"type\">int</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>这个表的主要用途是为管理层准备在线报告，因此大部分查询只会访问上周、上个月或者前一季度的数据。为了减少需要被存放的旧数据量，我们决定只保留最近3年的数据。在每个月的开始我们会删除掉最早的那个月的数据。在这种情况下我们可以使用分区表技术来帮助我们满足对<code>measurement</code>表的所有不同需求。</p>\n<p>要在这种情况下使用声明式分区，可采用下面的步骤：</p>\n<ol>\n<li>通过指定<code>PARTITION BY</code>子句把<code>measurement</code>表创建为分区表，该子句包括分区方法（这个例子中是<code>RANGE</code>）以及用作分区键的列。一方面可以在分区键中使用多列进行范围分区，当然，这通常会导致分区数量比较多，其中每一个分区都比较小。另一方面，使用较少的列会通过粗粒度的分区策略得到较少数量的分区。</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement (</span><br><span class=\"line\">    city_id         <span class=\"type\">int</span> <span class=\"keyword\">not null</span>,</span><br><span class=\"line\">    logdate         <span class=\"type\">date</span> <span class=\"keyword\">not null</span>,</span><br><span class=\"line\">    peaktemp        <span class=\"type\">int</span>,</span><br><span class=\"line\">    unitsales       <span class=\"type\">int</span></span><br><span class=\"line\">) <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">RANGE</span> (logdate);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建分区。每个分区的定义必须指定对应于父表的分区方法和分区键的边界。注意，如果指定的边界使得新分区的值会与已有分区中的值重叠，则会导致错误。向父表中插入无法映射到任何现有分区的数据也会导致错误，这种情况下应该增加一个合适的新分区。</li>\n</ol>\n<p>分区以普通表或者外部表的方式创建。可以为每个分区单独指定表空间<code>TABLESPACE</code>和存储参数。</p>\n<p>没有必要创建表约束来描述分区的分区边界条件，因为分区约束会自动地隐式地从分区边界说明中生成。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement_y2006m02 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> measurement</span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"string\">&#x27;2006-02-01&#x27;</span>) <span class=\"keyword\">TO</span> (<span class=\"string\">&#x27;2006-03-01&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement_y2006m03 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> measurement</span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"string\">&#x27;2006-03-01&#x27;</span>) <span class=\"keyword\">TO</span> (<span class=\"string\">&#x27;2006-04-01&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement_y2007m11 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> measurement</span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"string\">&#x27;2007-11-01&#x27;</span>) <span class=\"keyword\">TO</span> (<span class=\"string\">&#x27;2007-12-01&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement_y2007m12 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> measurement</span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"string\">&#x27;2007-12-01&#x27;</span>) <span class=\"keyword\">TO</span> (<span class=\"string\">&#x27;2008-01-01&#x27;</span>)</span><br><span class=\"line\">    TABLESPACE fasttablespace;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement_y2008m01 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> measurement</span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"string\">&#x27;2008-01-01&#x27;</span>) <span class=\"keyword\">TO</span> (<span class=\"string\">&#x27;2008-02-01&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">WITH</span> (parallel_workers <span class=\"operator\">=</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">    TABLESPACE fasttablespace;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在分区表的父表上创建一个索引，还有其他需要的索引（索引并不是必需的，但是大部分数据库应用场景中它都能发挥作用）。这会自动在每个分区上创建一个索引，并且后来创建或者关联的任何分区也将会包含该索引。</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX <span class=\"keyword\">ON</span> measurement (logdate);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>确保<code>enable_partition_pruning</code>配置参数在<code>postgresql.conf</code>中没有被禁用。如果被禁用，查询将不会按照想要的方式被优化。</li>\n</ol>\n<h2 id=\"维护分区表\"><a href=\"#维护分区表\" class=\"headerlink\" title=\"维护分区表\"></a>维护分区表</h2><p>通常在初始定义分区表时不会把所有需要的分区都建立好，因为后续可能需要移除旧分区的数据并且为新数据周期性地增加新分区。分区表的最大优势之一就是可以通过修改分区结构来轻松地完成这些任务，而不是批量删除或迁移大量数据。</p>\n<p>移除旧数据最简单的选择是删除掉不再需要的分区：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> measurement_y2006m02;</span><br></pre></td></tr></table></figure>\n\n<p>这可以非常快地删除数百万行记录，因为它不需要逐个删除每个记录。不过要注意上面的命令需要从父表上拿到<code>ACCESS EXCLUSIVE</code>锁。</p>\n<p>另一种通常更好的选项是把分区从分区表中移除，但是保留它作为一个独立的表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> measurement DETACH <span class=\"keyword\">PARTITION</span> measurement_y2006m02;</span><br></pre></td></tr></table></figure>\n\n<p>这允许在它被删除之前在其数据上执行进一步的操作，如使用<code>COPY</code>、<code>pg_dump</code>或类似工具备份数据。这也是把数据聚集成较小的格式、执行其他数据操作或者运行报表的好时机。</p>\n<p>类似地，我们可以增加一个新分区来处理新数据。我们可以在分区表中创建一个空分区，就像上面创建的初始分区那样：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> measurement_y2008m02 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> measurement</span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"string\">&#x27;2008-02-01&#x27;</span>) <span class=\"keyword\">TO</span> (<span class=\"string\">&#x27;2008-03-01&#x27;</span>)</span><br><span class=\"line\">    TABLESPACE fasttablespace;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以在分区的父表上创建索引，并自动将其应用于整个层次结构。这非常便利，因为不仅现有分区将自动创建索引，而且将来创建的任何分区都将自动创建索引。但是创建这样一个分区索引时，不可以使用<code>CONCURRENTLY</code>限定符。为了避免创建索引时的长时间锁，可以对父表使用<code>CREATE INDEX ON ONLY ...</code>，此时索引只会在父表上创建，并且子表不会自动创建该索引。子表上的索引可以使用<code>CONCURRENTLY</code>单独创建，然后使用<code>ALTER INDEX ... ATTACH PARTITION ...</code>关联到父索引。一旦所有子表的索引附加到父索引，父索引将自动生效。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX measurement_usls_idx <span class=\"keyword\">ON</span> <span class=\"keyword\">ONLY</span> measurement (unitsales);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> INDEX measurement_usls_200602_idx</span><br><span class=\"line\">    <span class=\"keyword\">ON</span> measurement_y2006m02 (unitsales);</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> INDEX measurement_usls_idx</span><br><span class=\"line\">    ATTACH <span class=\"keyword\">PARTITION</span> measurement_usls_200602_idx;</span><br></pre></td></tr></table></figure>\n\n<p>该操作也可以使用在<code>UNIQUE</code>和<code>PRIMARY KEY</code>约束中; 当创建约束时隐式创建索引。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> <span class=\"keyword\">ONLY</span> measurement <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> (city_id, logdate);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ALTER TABLE</span> measurement_y2006m02 <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> (city_id, logdate);</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> INDEX measurement_city_id_logdate_key</span><br><span class=\"line\">    ATTACH <span class=\"keyword\">PARTITION</span> measurement_y2006m02_city_id_logdate_key;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"需求场景\"><a href=\"#需求场景\" class=\"headerlink\" title=\"需求场景\"></a>需求场景</h2><p>在一个项目中，使用PostgreSQL11存储了大量的设备能耗数据，数据量达到了上亿行，查询效率极低，考虑将其转换成分区表存储数据。</p>\n<p>能耗数据<code>pecdeviceenergy</code>结构如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>columns</strong></th>\n<th><strong>data type</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>aggregationcycle</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>dataid</td>\n<td>bigint</td>\n</tr>\n<tr>\n<td>deviceid</td>\n<td>bigint</td>\n</tr>\n<tr>\n<td>energydata</td>\n<td>double</td>\n</tr>\n<tr>\n<td>logicalid</td>\n<td>integer</td>\n</tr>\n<tr>\n<td>logtime</td>\n<td>bigint</td>\n</tr>\n</tbody></table>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>原表DDL如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create table</span> pecdeviceenergy_bak</span><br><span class=\"line\">(</span><br><span class=\"line\">    id  <span class=\"type\">bigint</span> <span class=\"keyword\">default</span> nextval(<span class=\"string\">&#x27;public.pecdeviceenergy_id_seq&#x27;</span>::regclass) <span class=\"keyword\">not null</span></span><br><span class=\"line\">    <span class=\"keyword\">constraint</span> pecdeviceenergy_bak_pkey</span><br><span class=\"line\">        <span class=\"keyword\">primary key</span>,</span><br><span class=\"line\">    aggregationcycle <span class=\"type\">integer</span>,</span><br><span class=\"line\">    dataid           <span class=\"type\">bigint</span>,</span><br><span class=\"line\">    deviceid         <span class=\"type\">bigint</span>,</span><br><span class=\"line\">    energydata       <span class=\"type\">double precision</span>,</span><br><span class=\"line\">    logicalid        <span class=\"type\">integer</span>,</span><br><span class=\"line\">    logtime          <span class=\"type\">bigint</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>为了不影响切换成分区表机制后数据的正常录入，新的分区表应与原表结构保持一致，比较合适的分区规则是按<code>logtime</code>字段分区，为每个月的数据建一个子表；</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> IF <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> public.pecdeviceenergy</span><br><span class=\"line\">(</span><br><span class=\"line\">    id               bigserial <span class=\"keyword\">NOT NULL</span>,</span><br><span class=\"line\">    aggregationcycle <span class=\"type\">integer</span>,</span><br><span class=\"line\">    dataid           <span class=\"type\">bigint</span>,</span><br><span class=\"line\">    deviceid         <span class=\"type\">bigint</span>,</span><br><span class=\"line\">    energydata       <span class=\"type\">double precision</span>,</span><br><span class=\"line\">    logicalid        <span class=\"type\">integer</span>,</span><br><span class=\"line\">    logtime          <span class=\"type\">bigint</span>,</span><br><span class=\"line\">    <span class=\"keyword\">constraint</span> pecdeviceenergy_pkey</span><br><span class=\"line\">        <span class=\"keyword\">primary key</span> (id, logtime)</span><br><span class=\"line\">) <span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> <span class=\"keyword\">range</span> (logtime);</span><br></pre></td></tr></table></figure>\n\n<p>在此基础上，给父表建立必要的索引，保证子表的查询效率。新增的分区或者通过<code>ATTACH PARTITION</code>关联的分区都会自动创建相应的索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> index pecdeviceenergy_query_index <span class=\"keyword\">on</span> pecdeviceenergy (deviceid, logtime, aggregationcycle);</span><br></pre></td></tr></table></figure>\n\n<p>建立父表后，就可以开始建立子表了。实际上，建立索引和建立子表的步骤可以互换，不影响最终的表结构。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_01 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1640966400000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1643644800000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_02 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1643644800000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1646064000000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_03 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1646064000000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1648742400000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_04 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1648742400000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1651334400000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_05 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1651334400000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1654012800000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_06 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1654012800000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1656604800000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_07 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1656604800000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1659283200000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_08 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1659283200000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1661961600000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_09 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1661961600000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1664553600000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_10 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1664553600000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1667232000000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_11 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1667232000000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1669824000000</span>);</span><br><span class=\"line\"><span class=\"keyword\">CREATE TABLE</span> partition.pecdeviceenergy_2022_12 <span class=\"keyword\">PARTITION</span> <span class=\"keyword\">OF</span> public.pecdeviceenergy <span class=\"keyword\">FOR</span> <span class=\"keyword\">VALUES</span> <span class=\"keyword\">FROM</span> (<span class=\"number\">1669824000000</span>) <span class=\"keyword\">TO</span> (<span class=\"number\">1672502400000</span>);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>随后将旧表的数据导入至新表中。这里有多种方式可以达到目的，如批量插入、借助存储过程、使用<code>COPY</code>、<code>pg_dump</code>等等。此处使用最简单的批量插入操作，因为数据量非常大，所以需尽量避免在任务高峰期时执行，以免影响数据库其它事务的正常执行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">insert INTO</span> public.pecdeviceenergy(<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> public.pecdeviceenergy_bak);</span><br></pre></td></tr></table></figure>\n\n<p>最后将父表的主键<code>id</code>序列设置为所有<code>id</code>的最大值，避免新数据<code>id</code>重新从1开始记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">max</span>(public.pecdeviceenergy_bak.id)</span><br><span class=\"line\"><span class=\"keyword\">from</span> public.pecdeviceenergy_bak;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> SEQUENCE public.pecdeviceenergy_id_seq1 RESTART <span class=\"keyword\">WITH</span> ...;</span><br></pre></td></tr></table></figure>\n<p>至此，完成了将数据表<code>pecdeviceenergy</code>从普通表迁移至分区表的操作，可以通过<code>EXPLAIN</code>语句测试查询是否命中索引并执行<code>SELECT</code>语句观察查询效率是否提升。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">explain</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"string\">&#x27;pecdeviceenergy&#x27;</span> <span class=\"keyword\">as</span> modelLabel,</span><br><span class=\"line\">             id,</span><br><span class=\"line\">             aggregationcycle,</span><br><span class=\"line\">             dataid,</span><br><span class=\"line\">             deviceid,</span><br><span class=\"line\">             energydata,</span><br><span class=\"line\">             logicalid,</span><br><span class=\"line\">             logtime</span><br><span class=\"line\">      <span class=\"keyword\">FROM</span> public.pecdeviceenergy</span><br><span class=\"line\">      <span class=\"keyword\">WHERE</span> (deviceid <span class=\"keyword\">in</span> (<span class=\"number\">9871</span>, <span class=\"number\">9872</span>, <span class=\"number\">9873</span>, <span class=\"number\">9888</span>, <span class=\"number\">9889</span>, <span class=\"number\">9890</span>, <span class=\"number\">9925</span>, <span class=\"number\">9926</span>, <span class=\"number\">9927</span>, <span class=\"number\">9933</span>, <span class=\"number\">9934</span>, <span class=\"number\">9869</span>, <span class=\"number\">9909</span>, <span class=\"number\">9931</span>, <span class=\"number\">9932</span>) <span class=\"keyword\">AND</span></span><br><span class=\"line\">             dataid <span class=\"operator\">=</span> <span class=\"number\">4000004</span> <span class=\"keyword\">AND</span> logtime <span class=\"operator\">&gt;=</span> <span class=\"number\">1669824000000</span> <span class=\"keyword\">AND</span> logtime <span class=\"operator\">&lt;</span> <span class=\"number\">1672502400000</span> <span class=\"keyword\">AND</span> aggregationcycle <span class=\"operator\">=</span> <span class=\"number\">7</span>)</span><br><span class=\"line\">         <span class=\"keyword\">OR</span> (deviceid <span class=\"keyword\">in</span> (<span class=\"number\">9871</span>, <span class=\"number\">9872</span>, <span class=\"number\">9873</span>, <span class=\"number\">9888</span>, <span class=\"number\">9889</span>, <span class=\"number\">9890</span>, <span class=\"number\">9925</span>, <span class=\"number\">9926</span>, <span class=\"number\">9927</span>, <span class=\"number\">9933</span>, <span class=\"number\">9934</span>, <span class=\"number\">9869</span>, <span class=\"number\">9909</span>, <span class=\"number\">9931</span>, <span class=\"number\">9932</span>) <span class=\"keyword\">AND</span></span><br><span class=\"line\">             dataid <span class=\"operator\">=</span> <span class=\"number\">4000004</span> <span class=\"keyword\">AND</span> logtime <span class=\"operator\">&gt;=</span> <span class=\"number\">1669824000000</span> <span class=\"keyword\">AND</span> logtime <span class=\"operator\">&lt;</span> <span class=\"number\">1672502400000</span> <span class=\"keyword\">AND</span> aggregationcycle <span class=\"operator\">=</span> <span class=\"number\">12</span>)</span><br><span class=\"line\">         <span class=\"keyword\">OR</span> (deviceid <span class=\"keyword\">in</span> (<span class=\"number\">9871</span>, <span class=\"number\">9872</span>, <span class=\"number\">9873</span>, <span class=\"number\">9888</span>, <span class=\"number\">9889</span>, <span class=\"number\">9890</span>, <span class=\"number\">9925</span>, <span class=\"number\">9926</span>, <span class=\"number\">9927</span>, <span class=\"number\">9933</span>, <span class=\"number\">9934</span>, <span class=\"number\">9869</span>, <span class=\"number\">9909</span>, <span class=\"number\">9931</span>, <span class=\"number\">9932</span>) <span class=\"keyword\">AND</span></span><br><span class=\"line\">             dataid <span class=\"operator\">=</span> <span class=\"number\">4000004</span> <span class=\"keyword\">AND</span> logtime <span class=\"operator\">=</span> <span class=\"number\">1669824000000</span> <span class=\"keyword\">AND</span> aggregationcycle <span class=\"operator\">=</span> <span class=\"number\">14</span>);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><h2 id=\"建表建议\"><a href=\"#建表建议\" class=\"headerlink\" title=\"建表建议\"></a>建表建议</h2><ul>\n<li><p>分区键离散，可以使用<code>PARTITION BY LIST</code>，按字符串匹配决定落入哪个分区。</p>\n</li>\n<li><p>分区键连续，比如整形、日期等，可以使用<code>PARTITION BY RANGE</code>。</p>\n</li>\n<li><p>分区键数据随机无规律或规律简单，可以使用<code>PARTITION BY HASH</code>，用<code>hash</code>函数打散数据。</p>\n</li>\n<li><p>分区键数据随机有规律，规律复杂，可以使用多级混合分区，使数据平均分散、减少耦合。</p>\n</li>\n<li><dl><dt>每个分区都是一个普通PG表：</dt><dd>可以指定表空间：例如按月份分区的场景，可以把历史非活跃数据通过表空间指定到慢速廉价存储上，新的热数据保存到快速存储上。<br>可以指定并发度：给数据表设置并发度<code>parallel_workers</code>，让查询自动使用并行查询。</dd></dl></li>\n</ul>\n<h2 id=\"查询建议\"><a href=\"#查询建议\" class=\"headerlink\" title=\"查询建议\"></a>查询建议</h2><ul>\n<li><p>不带分区键的查询或带分区键但涉及大部分分区表的查询会使执行计划成倍增长，在分区表很多时会消耗大量内存，生成执行计划的时间也会变长。存在几千个分区时可能<code>Planning time</code>会超过<code>Execution time</code>。</p>\n</li>\n<li><p>分区数量的增长应该在设计时就有预期，根据表大小评估，一般最好不要上千。</p>\n</li>\n<li><p>分区间最好是没有数据依赖（比如按月份分区可以很方便的删除某一个分区），如果删除一个分区需要把部分数据调整到其他分区，新增一个分区需要从其他分区拿数据，这样效率会很差。</p>\n</li>\n</ul>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"http://www.postgres.cn/docs/12/ddl-partitioning.html\">5.11. 表分区</a></li>\n<li><a href=\"https://blog.csdn.net/qq_38567039/article/details/119751897\">PostgreSQL数据库表分区介绍-四种分区方式</a></li>\n<li><a href=\"https://blog.csdn.net/yang_z_1/article/details/117730158\">postgresql 创建分区表 以及拆分分区表（修改分区）</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2123226\">Postgresql分区表大量实例与分区建议（LIST &#x2F; RANGE &#x2F; HASH &#x2F; 多级混合分区）</a></li>\n</ul>\n","categories":["学习笔记"],"tags":["数据库"]},{"title":"实战pgBackRest","url":"/posts/79c746af1ae0.html","content":"<p>pgBackRest是一款开源的备份还原工具，目标旨在为备份和还原提供可靠易用的备份。</p>\n<p>操作系统：CentOS 7.9<br>pgBackRest版本：2.37<br>PostgreSQL版本：11.5</p>\n<h1 id=\"约定\"><a href=\"#约定\" class=\"headerlink\" title=\"约定\"></a>约定</h1><p>本文中使用两台服务器分别作为数据库服务器和备份服务器，数据库服务器主机命名为pg-primary、备份服务器主机命名为repository。</p>\n<p>为了方便后续维护，在两台服务器上修改hosts文件，每台服务器添加一条ip为对方服务器的host记录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> vim /etc/hosts</span><br></pre></td></tr></table></figure>\n\n<p>在数据库服务器上添加以下记录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">repository-server-ip repository</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>repository-server-ip</code>为备份服务器ip，例如：<code>10.12.137.123 repository</code></p>\n<p>在备份服务器上添加以下记录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">database-server-ip pg-primary</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>database-server-ip</code>为数据库服务器ip，例如：<code>10.12.137.29 pg-primary</code></p>\n<h1 id=\"配置步骤\"><a href=\"#配置步骤\" class=\"headerlink\" title=\"配置步骤\"></a>配置步骤</h1><ol>\n<li><p>将pgBackRest源代码编译成二进制文件pgbackrest。（编译过程略）</p>\n</li>\n<li><p>为了避免与postgres用户混淆，在备份服务器上创建用户pgbackrest</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> groupadd pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> useradd -g pgbackrest pgbackrest</span><br></pre></td></tr></table></figure>\n\n<p>为pgbackrest用户设置一个密码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> passwd pgbackrest</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在备份服务器上使用pgbackrest用户生成ssh密钥</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">mkdir</span> -m 750 /home/pgbackrest/.ssh</span><br><span class=\"line\">$ ssh-keygen -f /home/pgbackrest/.ssh/id_rsa -t rsa -N <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>在数据库服务器上使用postgres用户生成ssh密钥</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su postgres</span><br><span class=\"line\">$ <span class=\"built_in\">mkdir</span> -m 750 -p /var/lib/pgsql/.ssh</span><br><span class=\"line\">$ ssh-keygen -f /var/lib/pgsql/.ssh/id_rsa -t rsa -N <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：pgbackrest用户的主目录是&#x2F;home&#x2F;pgbackrest；postgres用户的主目录是&#x2F;var&#x2F;lib&#x2F;pgsql。最好将ssh密钥生成在各自用户的主目录下。</p>\n</blockquote>\n<ol start=\"4\">\n<li>在两台服务器之间交换公钥</li>\n</ol>\n<p>在备份服务器上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su pgbackrest</span><br><span class=\"line\">$ ssh-copy-id postgres@pg-primary</span><br></pre></td></tr></table></figure>\n\n<p>在数据库服务器上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su postgres</span><br><span class=\"line\">$ ssh-copy-id pgbackrest@repository</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>在两台服务器上测试无密码连接</li>\n</ol>\n<p>在备份服务器上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su pgbackrest</span><br><span class=\"line\">$ ssh postgres@pg-primary</span><br></pre></td></tr></table></figure>\n\n<p>在数据库服务器上：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su postgres</span><br><span class=\"line\">$ ssh pgbackrest@repository</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>将pgbackrest二进制文件部署到&#x2F;usr&#x2F;bin目录下，并赋予访问权限</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> 755 /usr/bin/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> pgbackrest:pgbackrest /usr/bin/pgbackrest</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>在备份服务器上创建pgBackRest配置文件、目录和仓库</li>\n</ol>\n<blockquote>\n<p>注意：新建的pgbackrest用户没有加入到sudo名单中，无法执行sudo命令</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p -m 770 /var/log/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> pgbackrest:pgbackrest /var/log/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/pgbackrest/conf.d</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">touch</span> /etc/pgbackrest/pgbackrest.conf</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> 640 /etc/pgbackrest/pgbackrest.conf</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> pgbackrest:pgbackrest /etc/pgbackrest/pgbackrest.conf</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p -m 750 /var/lib/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> pgbackrest:pgbackrest /var/lib/pgbackrest</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>配置备份服务器</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> vim /etc/pgbackrest/pgbackrest.conf</span><br></pre></td></tr></table></figure>\n\n<p>写入下列配置项：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">repo1-path=/var/lib/pgbackrest</span><br><span class=\"line\">repo1-retention-full=1</span><br><span class=\"line\">log-level-console=info</span><br><span class=\"line\">log-level-file=detail</span><br><span class=\"line\">start-fast=y</span><br><span class=\"line\">delta=y</span><br><span class=\"line\"></span><br><span class=\"line\">[db1]</span><br><span class=\"line\">pg1-database=Matterhorn_HNHB</span><br><span class=\"line\">pg1-path=/var/lib/pgsql/11/data</span><br><span class=\"line\">pg1-host=10.12.137.29</span><br><span class=\"line\">pg1-port=25433</span><br><span class=\"line\">pg1-user=postgres</span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>配置数据库服务器，步骤与配置备份服务器相似</li>\n</ol>\n<p>先部署pgbackrest二进制文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> 755 /usr/bin/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> postgres:postgres /usr/bin/pgbackrest</span><br></pre></td></tr></table></figure>\n\n<p>然后创建目录：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p -m 770 /var/log/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> postgres:postgres /var/log/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p /etc/pgbackrest/conf.d</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">touch</span> /etc/pgbackrest/pgbackrest.conf</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chmod</span> 640 /etc/pgbackrest/pgbackrest.conf</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> postgres:postgres /etc/pgbackrest/pgbackrest.conf</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">mkdir</span> -p -m 750 /var/lib/pgbackrest</span><br><span class=\"line\">$ <span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> postgres:postgres /var/lib/pgbackrest</span><br></pre></td></tr></table></figure>\n\n<p>再写入配置项：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> vim /etc/pgbackrest/pgbackrest.conf</span><br></pre></td></tr></table></figure>\n\n<p>写入下列配置项：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">repo1-host=10.12.137.124</span><br><span class=\"line\">repo1-host-user=pgbackrest</span><br><span class=\"line\">repo1-path=/var/lib/pgbackrest</span><br><span class=\"line\">log-level-console=info</span><br><span class=\"line\">log-level-file=detail</span><br><span class=\"line\"></span><br><span class=\"line\">[db1]</span><br><span class=\"line\">pg1-path=/var/lib/pgsql/11/data</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>在数据库服务器上，更新postgresql.conf文件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> vim /var/lib/pgsql/11/data/postgresql.conf</span><br></pre></td></tr></table></figure>\n\n<p>找到对应配置项，进行如下更改：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">archive_mode = on</span><br><span class=\"line\">archive_command = &#x27;pgbackrest --stanza=db1 archive-push %p&#x27;</span><br><span class=\"line\">wal_level = replica</span><br></pre></td></tr></table></figure>\n\n<p>更新pg_hba.conf文件，数据库需要设置信任ip，否则pgBackRest无法连接上数据库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> vim /var/lib/pgsql/11/data/pg_hba.conf</span><br></pre></td></tr></table></figure>\n\n<p>将local和ipv4 local连接改为trust：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># &quot;local&quot; is for Unix domain socket connections only</span><br><span class=\"line\">local   all             all                                       trust</span><br><span class=\"line\"># IPv4 local connections:</span><br><span class=\"line\">host    all             all             127.0.0.1/32              trust</span><br></pre></td></tr></table></figure>\n\n<p>然后重启postgresql服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ systemctl restart postgresql-11.service</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"备份步骤\"><a href=\"#备份步骤\" class=\"headerlink\" title=\"备份步骤\"></a>备份步骤</h1><h2 id=\"执行备份\"><a href=\"#执行备份\" class=\"headerlink\" title=\"执行备份\"></a>执行备份</h2><ol>\n<li>在备份服务器上创建节点</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su pgbackrest</span><br><span class=\"line\">$ pgbackrest --stanza=db1 stanza-create</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>检查配置和节点信息</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pgbackrest --stanza=db1 check</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在备份服务器上创建第一份备份，该备份为全量备份</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pgbackrest --stanza=db1 backup</span><br></pre></td></tr></table></figure>\n\n<p>创建全量备份后，后续创建的备份默认为增量备份，可通过<code>--type</code>参数指定创建何种类型的备份。</p>\n<p>pgBackRest支持以下备份类型：</p>\n<ul>\n<li><code>full</code>全量备份，即复制所有数据库文件，并且不会依赖于以前的备份。</li>\n<li><code>incr</code>从上一次备份开始增量备份，基于全量或增量备份。</li>\n<li><code>diff</code>类似于增量备份，但始终基于上次全量备份。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pgbackrest --stanza=db1 --<span class=\"built_in\">type</span>=incr backup</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>通过以下命令查看备份节点的情况</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">sudo</span> -u pgbackrest pgbackrest --stanza=db1 info</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时备份\"><a href=\"#定时备份\" class=\"headerlink\" title=\"定时备份\"></a>定时备份</h2><p>现场环境可以考虑配置一个定时任务来定时执行数据备份。linux内置的cron进程能帮我们实现这些需求，cron搭配shell脚本，非常复杂的指令也没有问题。</p>\n<p><code>crontab</code>是用于管理linux定时任务的命令。<code>crontab</code>命令语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">crontab [-u username]  // 省略用户表示操作当前用户的crontab</span><br><span class=\"line\">    -e      (编辑工作表)</span><br><span class=\"line\">    -l      (列出工作表里的命令)</span><br><span class=\"line\">    -r      (删除工作表)</span><br></pre></td></tr></table></figure>\n\n<p>crontab使用的cron表达式和java相比有一些差别，crond不能指定秒，时间格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">f1 f2 f3 f4 f5 program</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>f1</code>是表示分钟，<code>f2</code>表示小时，<code>f3</code>表示一个月份中的第几日，<code>f4</code>表示月份，<code>f5</code>表示一个星期中的第几天，<code>program</code>表示要执行的程序或shell脚本。</p>\n<p>当<code>f1</code>为<code>*</code>时表示每分钟都要执行，<code>f2</code>为<code>*</code>时表示每小时都要执行，其余依此类推。</p>\n<p>当<code>f1</code>为<code>a-b</code>时表示从第a分钟到第b分钟这段时间内要执行，<code>f2</code>为<code>a-b</code>时表示从第a到第b小时都要执行，其余依此类推。</p>\n<p>当<code>f1</code>为<code>*/n</code>时表示每n分钟执行一次，<code>f2</code>为<code>*/n</code>表示每n小时执行一次，其余依此类推。</p>\n<p>当<code>f1</code>为<code>a, b, c, ...</code>时表示第a, b, c, …分钟要执行，<code>f2</code>为<code>a, b, c, ...</code>时表示第a, b, c, …个小时要执行，其余依此类推。</p>\n<p>对于pgBackRest定时任务，可以设置每周一次全量备份、每天一次增量备份：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ su pgbackrest</span><br><span class=\"line\">$ crontab -e</span><br></pre></td></tr></table></figure>\n\n<p>写入下列配置项：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 2 * * 0 /usr/bin/pgbackrest --type=full --stanza=db1 backup</span><br><span class=\"line\">0 2 * * 1-6 /usr/bin/pgbackrest --type=diff --stanza=db1 backup</span><br></pre></td></tr></table></figure>\n\n<p>这些配置项为pgbackrest用户指定了两个配置项，即每周日凌晨2点执行一次全量备份，每周一至周六凌晨2点执行一次增量备份。</p>\n<h1 id=\"还原\"><a href=\"#还原\" class=\"headerlink\" title=\"还原\"></a>还原</h1><p>执行还原前，需停止postgresql服务，并且必须从pg数据库目录中删除所有文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ systemctl stop postgresql-11.service</span><br><span class=\"line\">$ su postgres</span><br><span class=\"line\">$ find /var/lib/pgsql/11/data -mindepth 1 -delete</span><br></pre></td></tr></table></figure>\n\n<p>随后执行还原命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pgbackrest --stanza=demo restore</span><br></pre></td></tr></table></figure>\n\n<p>该命令相当于恢复整个data目录的文件。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>参考文章： (感谢以下资料提供的帮助)</p>\n<ul>\n<li><a href=\"https://pgbackrest.org/user-guide.html\">pgBackRest User Guide</a></li>\n<li><a href=\"https://pgbackrest.org/configuration.html\">pgBackRest Configuration Reference</a></li>\n</ul>\n","categories":["经验分享"],"tags":["数据库","服务器"]},{"title":"拉威尔《波莱罗（Bolero）》音乐特征与配器分析","url":"/posts/d6312cf2a1a8.html","content":"<iframe style=\"border-style:none;width:330px;height:86px;\" src=\"//music.163.com/outchain/player?type=2&id=32680467&auto=0&height=66\"></iframe>\n\n<h1 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h1><p>在一系列的研究中，当前关于《波莱罗》这部作品的分析虽种类繁多，但大多都是一些对音乐的赏析和评论之类的文章，对这部作品实质内容上的研究不够深入详尽。这部作品作为一部大型的管弦乐作品，却是以不变的旋律、和声与节奏贯穿首尾，完全依靠拉威尔独特的乐队音响思维和管弦乐技法组织、发展到统一，从音色的变化到织体声部不断的丰富，始终牢牢地牵引着人们。随着音乐情绪的不断高涨，人们的情绪也随之激情澎湃，这种独特而又神奇的魅力正是我决定对此作品进行深入研究的原因。</p>\n<p>本文以这部管弦乐作品中的配器、结构和表现手法作为研究对象，从谱面分析、音响结构两个方面，并结合拉威尔所处的时代，深入探究拉威尔自身风格的艺术理想和美学追求，试图感受这位伟大作曲家在晚年时的思想与心境。</p>\n<h1 id=\"拉威尔与《波莱罗》\"><a href=\"#拉威尔与《波莱罗》\" class=\"headerlink\" title=\"拉威尔与《波莱罗》\"></a>拉威尔与《波莱罗》</h1><h2 id=\"《波莱罗》简介\"><a href=\"#《波莱罗》简介\" class=\"headerlink\" title=\"《波莱罗》简介\"></a>《波莱罗》简介</h2><p>波莱罗（Bolero），原本是指一种特别的西班牙舞蹈，其音乐特征通常以四三拍子并伴随响板击打节奏来配合。结构上一般由主部、中部和再现部构成；音乐上，其速度适中、节奏鲜明、情绪欢愉。时至今日，西班牙人每年都会在他们的传统节日上跳这种欢快的舞蹈。</p>\n<p>虽然该曲使用了西班牙这一传统舞蹈的名称，但这仅仅只是一个名称，其实质的音乐内容，不论从曲式结构，还是旋律、节奏和速度来看，都与西班牙民间的舞曲之间没有太大的联系。</p>\n<h2 id=\"拉威尔的艺术创作\"><a href=\"#拉威尔的艺术创作\" class=\"headerlink\" title=\"拉威尔的艺术创作\"></a>拉威尔的艺术创作</h2><p>早期印象派音乐热衷于明暗对比、光明与阴影神秘的游戏，自我陶醉在冗长世界中。而拉威尔作为印象派音乐家则是大大发展了音乐的表现力，他的音乐中充满了五彩缤纷的烟火和充满诗意的洪亮声响，在追求音乐思想的自由与创新的同时，他传承维也纳古典乐派的严谨，以独创的手法形成他自己独特的音乐语言和作品形式。拉威尔的早期创作离不开德彪西的革新思想，但他的创作倾向却更接近斯特拉文斯基。在第一次世界大战之后，他的创作变得更加严谨朴素，回到更古老纯粹的法国传统音乐，同法国民族民间音乐，特别是同西班牙民间音乐保持更为密切的联系。</p>\n<h2 id=\"拉威尔与《波莱罗》-1\"><a href=\"#拉威尔与《波莱罗》-1\" class=\"headerlink\" title=\"拉威尔与《波莱罗》\"></a>拉威尔与《波莱罗》</h2><p>1928年，西班牙芭蕾舞女演员伊达·鲁宾斯坦约请拉威尔为她写一篇舞蹈音乐，拉威尔了解了这位女舞蹈家的想法之后，在他的心中已经开始酝酿着一个配器构思：要把这首作品写成一首乐队练习曲，全曲是一个巨大的渐强，所有乐器先后在不同的力度上加入乐队演奏，随着情绪逐渐高涨，音乐织体越来越丰满，最后音乐在狂欢的气氛中结束。</p>\n<p>《波莱罗》是拉威尔一生中最后一首管弦乐作品，该曲写成之后，在1928年于巴黎歌剧院首演，1930年之后该作品成为了所有管弦乐团的必备曲目。在听过此曲的人中，有很多人都称其是“好像有魔力一样，一口气从头听到了癫狂的结尾”。由此可见，《波莱罗》这首经典作品有着令人沉醉的独特魅力。</p>\n<h1 id=\"《波莱罗》中的音乐特征\"><a href=\"#《波莱罗》中的音乐特征\" class=\"headerlink\" title=\"《波莱罗》中的音乐特征\"></a>《波莱罗》中的音乐特征</h1><p>本节从曲式、和声和调性上用不同的分析角度来探究该曲的音乐特征，尽可能地做到对音乐作品的各个元素都能够涉及，尽可能地保证对作品研究的全面性。</p>\n<h2 id=\"非常规的双主题变奏\"><a href=\"#非常规的双主题变奏\" class=\"headerlink\" title=\"非常规的双主题变奏\"></a>非常规的双主题变奏</h2><p>《波莱罗》是一部双主题管弦乐变奏曲，曲式结构可分为七个部分，由引子开始，5-72小节为主题呈示，包含A、B两个主题，73-148小节为第一次变奏，149-220小节为第二变奏，221-292小节为第三变奏，293-334小节为第四变奏，第四次变奏后是乐曲的尾声部分。全曲从C大调开始，从主题呈示直到第四次变奏结束，在尾声部分转入E大调，随后又回到C大调结束。</p>\n<p>乐曲开始引子部分，由小军鼓在很弱（pp）的力度上进入，以两个连续的前八后十六三连音与均分节奏组合，两个前八后十六三连音与六连音组合而成的两小节循环节奏作为全曲的固定节奏背景贯穿始终。</p>\n<p>第一主题（5-21小节）在C大调上呈示，旋律单纯明朗，基本在一个八度之内。第二主题（41-57小节）旋律在性格上与第一主题产生对比，形象略显粗犷，带有神秘色彩，音域也扩展至两个八度，节奏也相对复杂多变，但并没有出现新的材料，主要还是从第一主题的材料中衍生出来。另外，两个主题的关系似乎是某种应答关系，互相呼应辅助，形成一问一答的对话式的旋律。</p>\n<p>变奏曲式对主题变奏的手法是多样的，但通常是对主题旋律、音型、节奏、节拍、和声等进行变奏，而拉威尔在写作《波莱罗》时则没有在这些常规的音乐素材中做出选择，而是通过乐队编配和力度上的改变来达到变奏的效果。拉威尔将这两个对比并置的主题每次各呈示两遍，两个主题均为8+9的非对称性乐句，如此反复交替出现五次，不断将音乐推向热烈的高潮，最终在狂欢中圆满终止。</p>\n<h2 id=\"现代音乐思维的复合调性呈现\"><a href=\"#现代音乐思维的复合调性呈现\" class=\"headerlink\" title=\"现代音乐思维的复合调性呈现\"></a>现代音乐思维的复合调性呈现</h2><p>虽然《波莱罗》的调式看似全曲都在C大调上，没有复杂的转调，直到尾声才转到E大调上，在短暂的转调后又回到了C大调上。尽管如此，实际并非表面看上去那么简单，经过仔细的研究之后，我们不难发现该作品的调式并不是那么简单的C大调。</p>\n<p>其一，拉威尔在这部作品中使用了混合调式，混合调式是指在主调中引入其他调式的特征音，从而形成多种调式的交替，这种多种调式的结合运用就是混合调式。在该作品中，这种混合调式的运用体现在主题B中，主题B前8小节在调式上是弗里几亚调式，但出现了bB和bD这两个音，在这里笔者认为是作曲家根据音乐需要加入的具有西班牙民族特色的音程，从而构成了这个非自然的具有西班牙风情的弗里几亚调式。而主题B的后一句，很显然的又回到了C旋律大调上，虽然有这种混合调式的加入，但整体的调性始终都没有脱离C大调的中心。</p>\n<p>其二，复合调性的使用，复合调性具体表现为在一个音乐段落的不同层次中使用不同的调性的在纵向上的结合，使音乐具有两个调性的特征。在第二次变奏中我们可以发现，木管组的两支长笛，分别在E大调和G大调上，他们与主调C大调从纵向上形成了平行的大三和弦的叠置，构成十分明亮的又隐约带有尖锐的音响，感觉就要冲破传统调性的框架，却又始终在传统调性的边缘徘徊。</p>\n<h2 id=\"主属持续的简约框架\"><a href=\"#主属持续的简约框架\" class=\"headerlink\" title=\"主属持续的简约框架\"></a>主属持续的简约框架</h2><p>《波莱罗》并没有复杂的和声，低音从始至终都维持着C大调的主属的交替，全曲的和声几乎在一层不变的低音框架内，稳固地建立在C大调的主属功能上，以不断加厚和不断复杂的声部结合，一次又一次的随着变奏而重复。</p>\n<h1 id=\"《波莱罗》配器及宏观上的“巨大渐强”\"><a href=\"#《波莱罗》配器及宏观上的“巨大渐强”\" class=\"headerlink\" title=\"《波莱罗》配器及宏观上的“巨大渐强”\"></a>《波莱罗》配器及宏观上的“巨大渐强”</h1><p>拉威尔自己评价自己的这部作品时曾说：“乐曲写法从头至尾简简单单没有炫技的意图”。但正是因为《波莱罗》这部作品在配器上如此的清晰，简洁，却又如此的迷人，才真正体现了一位作曲家的自信，这足以证明一位拥有高超配器法的作曲家在管弦乐的写作上已经达到返璞归真的境界。</p>\n<h2 id=\"配器及各阶段的力度变奏\"><a href=\"#配器及各阶段的力度变奏\" class=\"headerlink\" title=\"配器及各阶段的力度变奏\"></a>配器及各阶段的力度变奏</h2><p>本曲是三管编制的乐队作品，另外添加了两支萨克斯，来为音乐增添音色上的对比和加强整体音响上的色彩性。</p>\n<p>以旋律在配器上的变化来看，这部作品的配器大致可划分为四个阶段。第一阶段（1-147小节），这一阶段的特点都是使用独奏乐器的单一音色，并且这一阶段的旋律都采用单声部呈示。在此阶段担任旋律声部的乐器依次为：用极弱（pp）力度演奏的1长笛；弱（p）力度演奏的1单簧管和1大管；中弱（mp）力度演奏的木管组和1小号。</p>\n<p>第二阶段（147-220小节），这一阶段是两个主题的第二次变奏，此时旋律已呈多声部平行状态，木管组与弦乐组开始逐渐加厚音响。在此阶段担任旋律声部的乐器依次为：用中强（mf）力度演奏主题A4的1圆号、1钢片琴和木管组乐器；用同样力度演奏主题A5的木管组乐器；用中强力度演奏主题B4的1长号；用同样力度演奏主题B5的木管组乐器。</p>\n<p>第三阶段（221-292小节），这是两个主题交替出现的第三次变奏，这一阶段以弦乐和木管的音色逐渐混合，引导铜管组开始巧妙地加入伴奏。在此阶段担任旋律声部的乐器依次为：用强（f）力度演奏主题A6的木管组和小提琴I；用同样力度演奏主题A7的木管组和小提琴I、II；用强力度演奏主题B6的木管组、1小号和小提琴I、II；用同样力度演奏主题B7的木管组、1长号和弦乐组乐器。</p>\n<p>第四阶段（293至曲终），此时音乐的情绪已经逐渐高涨，铜管乐器与打击乐器有序的加入到乐队的齐奏中来，此时丰富的织体使音响结实且充满力量，音乐情绪热情激烈。在此阶段担任旋律声部的乐器依次为：用极强（ff）力度演奏主题A8的木管组、铜管组和小提琴I；用同样力度演奏主题B8的木管组、4小号和小提琴I；用最强（fff）力度演奏尾声的木管组、铜管组和后两小节大齐奏。</p>\n<p>从各阶段的配器和力度变化我们可以看出《波莱罗》在配器上是一个逐渐加厚的过程，在力度上从开始的pp到结束的fff，这正印证了拉威尔本人所说的“整首乐曲就一个巨大的渐强”，然而这种阶梯式的逐渐增强，并不是一成不变的力度递增，其中还经历了一些迂回转折，这种回旋式上升的方式给予了音乐足够的动力，生动地展现了音乐的情绪变化。</p>\n<h2 id=\"复合织体的运用及其反映出的“新音响”概念\"><a href=\"#复合织体的运用及其反映出的“新音响”概念\" class=\"headerlink\" title=\"复合织体的运用及其反映出的“新音响”概念\"></a>复合织体的运用及其反映出的“新音响”概念</h2><p>音乐的织体是一种音乐的结构形式，在管弦乐作品中可以分为以下几种要素：旋律、副旋律、低音、装饰声部、补充声部、背景声部以及和声，这些要素把各种音响编织成一部完整的音乐作品。</p>\n<p>拉威尔在这部作品中运用了不同乐器组之间音色的区别来组织各个声部，比如木管演奏旋律，弦乐则为其伴奏；反过来，弦乐做旋律时，木管来做伴奏。除了运用不同音色，还可以从音区高低的对比手法来分层，由于纵向上各个乐器音色不同，所以我们能清晰辨识出各个声部。</p>\n<p>从主题旋律第一次进入，我们就可以看出背景声部是由两个声部组成：小军鼓的固定节奏和弦乐组的节奏伴奏，其中弦乐组又可细分为中提琴和大提琴两个声部。通过乐器间不同音色的分层来凸显各个声部，背景声部和旋律声部就层次清晰的展现出来。</p>\n<p>然而，我们可以看到音乐的其他部分也有使用相同音色或同组别的乐器构成的对立性织体，这种并置的织体要通过相对的不同音区、节奏、演奏法来体现其声部层次。在这部作品中就常有弦乐组利用乐器不同的音区、节奏和演奏法来使各个织体的层次清晰，使其不埋没在众多声部之中。</p>\n<p>不论怎样从纵向、横向或是两者兼备的角度来分析管弦乐的织体，对于拉威尔所属的印象主义音乐作曲家而言，他们更多的是对音响色彩的要求，或是偏爱。而传统和声“功能性”的音响结构已经不再满足他们的艺术追求，毫无疑问的，这种“复合织体结构”所带来的“新音响”已经对传统的音响结构观念造成了一定程度的冲击，这种对声音音响色彩性，即“非功能性音响”的追求，正是推动音乐不断发展和创新的强有力的动力，为现代音乐的出现提供了思想上的引导，为音乐的发展开拓了更宽广的道路。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>拉威尔作为印象派杰出的代表人物，他发展了印象派音乐的表现力，尽管他本人否认他属于印象派。在他的音乐中，不仅有对传统音乐的继承，也有颇具拉威尔个人特色的音乐语言。尽管他生活在一个充满革命的时代，各种现代作曲家开始展现新鲜的音乐形式，他始终坚持着自己对音乐最纯粹的追求，他不是任何一种作曲风格的奴隶，他也从未放弃过对前人音乐的研究，这种对音乐和艺术的执着是我非常敬佩的。</p>\n<p>《波莱罗》这部作品已经成为管弦乐的经典，其要表达的思想不只是那一段舞蹈场景，更深层的含义还有对战争的悲痛，求学道路中所遭遇的冷漠人心，以及对人们的生活变得如同机器一般，每天做着重复的事情而感到失落和讽刺。那不变的主题，机械般的节奏，以及始终循环的和声与旋律中隐约泄露的忧郁情绪，不禁引人深思这部作品所承载的深层含义和拉威尔的内心世界。</p>\n<hr>\n<p><strong>非常感谢你的阅读，辛苦了！</strong></p>\n<hr>\n<p>本文转自吕亚飞<a href=\"https://www.fx361.com/page/2021/1127/11891718.shtml\">拉威尔《波莱罗（Bolero）》音乐特征与配器分析</a></p>\n","categories":["杂谈"],"tags":["杂记"]}]